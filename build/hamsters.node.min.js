module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* jshint esversion: 6, curly: true, eqeqeq: true, forin: true */
	
	/***********************************************************************************
	* Title: Hamsters.js                                                               *
	* Description: 100% Vanilla Javascript Multithreading & Parallel Execution Library *
	* Author: Austin K. Smith                                                          *
	* Contact: austin@asmithdev.com                                                    *  
	* Copyright: 2015 Austin K. Smith - austin@asmithdev.com                           * 
	* License: Artistic License 2.0                                                    *
	***********************************************************************************/
	
	//Features
	
	
	var _habitat = __webpack_require__(2);
	
	var _habitat2 = _interopRequireDefault(_habitat);
	
	var _pool = __webpack_require__(3);
	
	var _pool2 = _interopRequireDefault(_pool);
	
	var _data = __webpack_require__(4);
	
	var _data2 = _interopRequireDefault(_data);
	
	var _wheel = __webpack_require__(5);
	
	var _wheel2 = _interopRequireDefault(_wheel);
	
	var _task = __webpack_require__(6);
	
	var _task2 = _interopRequireDefault(_task);
	
	var _memoize = __webpack_require__(7);
	
	var _memoize2 = _interopRequireDefault(_memoize);
	
	var _distribute = __webpack_require__(10);
	
	var _distribute2 = _interopRequireDefault(_distribute);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var hamstersjs = function () {
	
	  /**
	  * @constructor
	  * @function constructor - Sets properties for this class
	  */
	  function hamstersjs() {
	    'use strict';
	
	    _classCallCheck(this, hamstersjs);
	
	    this.version = '5.5.9';
	    this.run = this.hamstersRun.bind(this);
	    this.promise = this.hamstersPromise.bind(this);
	    this.init = this.inititializeLibrary.bind(this);
	    this.data = {};
	    this.pool = {};
	    this.wheel = {};
	    this.habitat = {};
	    this.memoize = {};
	  }
	
	  /**
	  * @function inititializeLibrary - Prepares & initializes Hamsters.js library
	  * @param {object} startOptions - Provided library functionality options
	  */
	
	
	  _createClass(hamstersjs, [{
	    key: 'inititializeLibrary',
	    value: function inititializeLibrary(startOptions) {
	      this.data = new _data2.default(this);
	      this.pool = new _pool2.default(this);
	      this.wheel = new _wheel2.default(this);
	      this.habitat = new _habitat2.default(this);
	      this.memoize = new _memoize2.default(this, 100); //Set a maximum of 100 memoized function results, LRU cache
	      this.distribute = new _distribute2.default(this);
	
	      this.processStartOptions(startOptions);
	
	      if (!this.habitat.legacy && this.habitat.persistence === true) {
	        this.pool.spawnHamsters(this.habitat.maxThreads);
	      }
	      this.maxThreads = this.habitat.maxThreads;
	      console.info('Hamsters.js ' + this.version + ' initialized using up to ' + this.habitat.maxThreads + ' threads');
	    }
	
	    /**
	    * @function processStartOptions - Adjusts library functionality based on provided options
	    * @param {object} startOptions - Provided library functionality options
	    */
	
	  }, {
	    key: 'processStartOptions',
	    value: function processStartOptions(startOptions) {
	      if (typeof startOptions !== 'undefined') {
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;
	
	        try {
	          for (var _iterator = Object.keys(startOptions)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var key = _step.value;
	
	            if (this.habitat.keys.includes(key.toLowerCase())) {
	              this.habitat[key] = startOptions[key];
	            } else {
	              this[key] = startOptions[key];
	            }
	          }
	        } catch (err) {
	          _didIteratorError = true;
	          _iteratorError = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	              _iterator.return();
	            }
	          } finally {
	            if (_didIteratorError) {
	              throw _iteratorError;
	            }
	          }
	        }
	      }
	      // Ensure legacy mode is disabled when we pass a third party worker library
	      var forceLegacyMode = typeof startOptions !== 'undefined' && typeof startOptions.legacy !== 'undefined';
	      if (forceLegacyMode) {
	        forceLegacyMode = startOptions.legacy;
	      }
	      if (typeof this.habitat.Worker === 'function' && !forceLegacyMode) {
	        this.habitat.legacy = this.habitat.isIE;
	      }
	    }
	
	    /**
	     * @async
	     * @function scheduleTask - Schedules a new function to be processed by the library
	     * @param {object} task - Provided library execution options
	     * @param {function} resolve - Parent function promise resolve method
	     * @param {function} reject - Parent function promise reject method
	     * @return {Promise} Promise object on completion
	     */
	
	  }, {
	    key: 'scheduleTask',
	    value: function scheduleTask(task, resolve, reject) {
	      var _this = this;
	
	      if (task.input.memoize) {
	        // Pass the task object to the memoized function
	        var memoizedFunction = this.memoize.memoize(function () {
	          return _this.pool.scheduleTask(task);
	        });
	        return memoizedFunction(task).then(resolve).catch(reject);
	      }
	      return this.pool.scheduleTask(task).then(resolve).catch(reject);
	    }
	
	    /**
	     * @async
	     * @function hamstersPromise - Calls library functionality using async promises
	     * @param {object} params - Provided library execution options
	     * @param {function} functionToRun - Function to execute
	     * @return {Promise} Promise resolving with results from functionToRun
	     */
	
	  }, {
	    key: 'hamstersPromise',
	    value: function hamstersPromise(params, functionToRun) {
	      var _this2 = this;
	
	      return new Promise(function (resolve, reject) {
	        _this2.scheduleTask(new _task2.default(_this2, params, functionToRun), resolve, reject);
	      });
	    }
	
	    /**
	    * @async
	    * @function hamstersRun - Calls library functionality using async callbacks
	    * @param {object} params - Provided library execution options
	    * @param {function} onError - Function to call upon execution failure
	    * @return {array} Results from functionToRun.
	    */
	
	  }, {
	    key: 'hamstersRun',
	    value: function hamstersRun(params, functionToRun, onSuccess, onError) {
	      this.scheduleTask(new _task2.default(this, params, functionToRun), onSuccess, onError);
	    }
	  }]);
	
	  return hamstersjs;
	}();
	
	var hamsters = new hamstersjs();
	
	module.exports = hamsters;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/* jshint esversion: 6, curly: true, eqeqeq: true, forin: true */
	
	/***********************************************************************************
	* Title: Hamsters.js                                                               *
	* Description: 100% Vanilla Javascript Multithreading & Parallel Execution Library *
	* Author: Austin K. Smith                                                          *
	* Contact: austin@asmithdev.com                                                    *  
	* Copyright: 2015 Austin K. Smith - austin@asmithdev.com                           * 
	* License: Artistic License 2.0                                                    *
	***********************************************************************************/
	
	var Habitat = function () {
	
	  /**
	  * @constructor
	  * @function constructor - Sets properties for this class
	  */
	  function Habitat(hamsters) {
	    'use strict';
	
	    _classCallCheck(this, Habitat);
	
	    this.hamsters = hamsters;
	    this.debug = false;
	    this.importScripts = null;
	    this.memoize = false;
	    this.persistence = true;
	    this.browser = this.isBrowser();
	    this.webWorker = this.isWebWorker();
	    this.node = this.isNode();
	    this.reactNative = this.isReactNative();
	    this.shell = this.isShell();
	    this.transferable = this.supportsTransferableObjects();
	    this.atomics = this.supportsAtomicOperations();
	    this.proxies = this.supportsProxies();
	    this.isIE = this.isInternetExplorer();
	    this.selectHamsterWheel = this.selectHamsterWheel.bind(this);
	    this.sharedWorker = this.locateSharedWorkerObject();
	    this.locateBlobBuilder = this.findAvailableBlobBuilder();
	    this.legacy = this.isLegacyEnvironment();
	    this.Worker = this.locateWorkerObject();
	    this.maxThreads = this.determineGlobalThreads();
	    this.keys = this.getHabitatKeys();
	  }
	
	  /**
	  * @function determineGlobalThreads - Determines max number of threads to use
	  */
	
	
	  _createClass(Habitat, [{
	    key: 'determineGlobalThreads',
	    value: function determineGlobalThreads() {
	      var max = 4;
	      if (this.browser && typeof navigator.hardwareConcurrency !== "undefined") {
	        max = navigator.hardwareConcurrency;
	        if (this.isFirefox()) {
	          max = max > 20 ? 20 : max;
	        }
	      }
	      if (this.node && typeof os !== 'undefined') {
	        max = os.cpus().length;
	      }
	      return max;
	    }
	
	    /**
	    * @function isFirefox - Detect firefox browser
	    */
	
	  }, {
	    key: 'isFirefox',
	    value: function isFirefox() {
	      if (typeof navigator !== "undefined" && typeof navigator.userAgent !== "undefined") {
	        return navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;
	      }
	      return false;
	    }
	
	    /**
	    * @function locateWorkerObject - Attempts to find a global Worker object
	    */
	
	  }, {
	    key: 'locateWorkerObject',
	    value: function locateWorkerObject() {
	      return typeof Worker !== 'undefined' ? Worker : false;
	    }
	
	    /**
	    * @function locateSharedWorkerObject - Attempts to find a global SharedWorker object
	    */
	
	  }, {
	    key: 'locateSharedWorkerObject',
	    value: function locateSharedWorkerObject() {
	      return typeof SharedWorker !== 'undefined' ? SharedWorker : false;
	    }
	
	    /**
	    * @function isBrowser - Detects if execution environment is a browser
	    */
	
	  }, {
	    key: 'isBrowser',
	    value: function isBrowser() {
	      return (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === "object";
	    }
	
	    /**
	    * @function isInternetExplorer - Detects if execution environment is internet explorer
	    */
	
	  }, {
	    key: 'isInternetExplorer',
	    value: function isInternetExplorer() {
	      if (typeof navigator !== "undefined" && typeof navigator.userAgent !== "undefined") {
	        return navigator.userAgent.indexOf("MSIE ") !== -1 || navigator.userAgent.indexOf("Trident/") !== -1;
	      }
	      return false;
	    }
	
	    /**
	    * @function isNode - Detects if execution environment is node.js
	    */
	
	  }, {
	    key: 'isNode',
	    value: function isNode() {
	      return (typeof process === 'undefined' ? 'undefined' : _typeof(process)) === "object" && "function" === "function" && !this.isWebWorker() && !this.browser;
	    }
	
	    /**
	    * @function isWebWorker - Detects if execution environment is a web worker
	    */
	
	  }, {
	    key: 'isWebWorker',
	    value: function isWebWorker() {
	      return typeof importScripts === "function" && !this.isReactNative();
	    }
	
	    /**
	    * @function isReactNative - Detects if execution environment is React Native
	    */
	
	  }, {
	    key: 'isReactNative',
	    value: function isReactNative() {
	      return typeof navigator !== "undefined" && typeof navigator.product !== "undefined" && navigator.product === "ReactNative";
	    }
	
	    /**
	    * @function isShell - Detects if execution environment is a shell
	    */
	
	  }, {
	    key: 'isShell',
	    value: function isShell() {
	      return typeof navigator === "undefined" && !this.isNode() && !this.isWebWorker() && !this.isReactNative();
	    }
	
	    /**
	    * @function isLegacyEnvironment - Detects if execution environment is a legacy environment
	    */
	
	  }, {
	    key: 'isLegacyEnvironment',
	    value: function isLegacyEnvironment() {
	      var isLegacy = !!!this.Worker;
	      // Detect sharedWorker support for use within webworkers
	      if (this.isWebWorker() && typeof this.SharedWorker !== 'undefined') {
	        isLegacy = !this.supportsSharedWorkers();
	      }
	      return isLegacy;
	    }
	
	    /**
	    * @function supportsSharedWorkers - Detects if execution environment supports SharedWorkers
	    */
	
	  }, {
	    key: 'supportsSharedWorkers',
	    value: function supportsSharedWorkers() {
	      var supports = false;
	      try {
	        var workerBlob = this.generateWorkerBlob(this.selectHamsterWheel());
	        var SharedHamster = new this.SharedWorker(workerBlob, 'SharedHamsterWheel');
	        supports = true;
	      } catch (e) {
	        supports = false;
	      }
	      return supports;
	    }
	
	    /**
	    * @function findAvailableBlobBuilder - Attempts to locate a data blob builder, with vendor prefixes
	    */
	
	  }, {
	    key: 'findAvailableBlobBuilder',
	    value: function findAvailableBlobBuilder() {
	      if (typeof BlobBuilder !== 'undefined') {
	        return BlobBuilder;
	      }
	      if (typeof WebKitBlobBuilder !== 'undefined') {
	        return WebKitBlobBuilder;
	      }
	      if (typeof MozBlobBuilder !== 'undefined') {
	        return MozBlobBuilder;
	      }
	      if (typeof MSBlobBuilder !== 'undefined') {
	        return MSBlobBuilder;
	      }
	      return 'Environment does not support data blobs!';
	    }
	
	    /**
	    * @function createDataBlob - Creates a new data blob from textContent
	    * @param {string} textContent - Provided text content for blob
	    */
	
	  }, {
	    key: 'createDataBlob',
	    value: function createDataBlob(textContent) {
	      if (typeof Blob === 'undefined') {
	        var BlobMaker = this.locateBlobBuilder();
	        var blob = new BlobMaker();
	        blob.append([textContent], {
	          type: 'application/javascript'
	        });
	        return blob.getBlob();
	      }
	      return new Blob([textContent], {
	        type: 'application/javascript'
	      });
	    }
	
	    /**
	    * @function generateWorkerBlob - Creates a blob URI for flexible scaffold loading
	    * @param {function} workerLogic - Scaffold to use within worker thread
	    */
	
	  }, {
	    key: 'generateWorkerBlob',
	    value: function generateWorkerBlob(workerLogic) {
	      return URL.createObjectURL(this.createDataBlob('(' + String(workerLogic) + ')();'));
	    }
	
	    /**
	    * @function supportsTransferableObjects - Detects if execution environment supports typed arrays
	    */
	
	  }, {
	    key: 'supportsTransferableObjects',
	    value: function supportsTransferableObjects() {
	      return typeof Uint8Array !== 'undefined';
	    }
	
	    /**
	    * @function supportsAtomicOperations - Detects if execution environment supports SharedArrayBuffers
	    */
	
	  }, {
	    key: 'supportsAtomicOperations',
	    value: function supportsAtomicOperations() {
	      return typeof SharedArrayBuffer !== 'undefined';
	    }
	
	    /**
	    * @function supportsProxies - Detects if execution environment supports Proxy objects
	    */
	
	  }, {
	    key: 'supportsProxies',
	    value: function supportsProxies() {
	      return typeof Proxy !== 'undefined';
	    }
	
	    /**
	    * @function selectHamsterWheel - Determines which scaffold to use for proper execution for various environments
	    */
	
	  }, {
	    key: 'selectHamsterWheel',
	    value: function selectHamsterWheel() {
	      if (this.isIE) {
	        return this.hamsters.wheel.legacy;
	      }
	      if (this.reactNative) {
	        return 'reactNativeHamster.js';
	      }
	      if (this.node) {
	        return './node_modules/hamsters.js/build/common/node.js';
	      }
	      return this.generateWorkerBlob(this.hamsters.wheel.regular);
	    }
	
	    /**
	    * @function getHabitatKeys - Returns keys for this Habitat instance
	    */
	
	  }, {
	    key: 'getHabitatKeys',
	    value: function getHabitatKeys() {
	      return ['worker', 'sharedworker', 'legacy', 'proxies', 'reactnative', 'atomics', 'transferable', 'browser', 'shell', 'node', 'debug', 'persistence', 'importscripts', 'maxthreads', 'parentport', 'webworker'];
	    }
	  }]);
	
	  return Habitat;
	}();
	
	module.exports = Habitat;

/***/ }),
/* 3 */
/***/ (function(module, exports) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/* jshint esversion: 6, curly: true, eqeqeq: true, forin: true */
	
	/***********************************************************************************
	* Title: Hamsters.js                                                               *
	* Description: 100% Vanilla Javascript Multithreading & Parallel Execution Library *
	* Author: Austin K. Smith                                                          *
	* Contact: austin@asmithdev.com                                                    *  
	* Copyright: 2015 Austin K. Smith - austin@asmithdev.com                           * 
	* License: Artistic License 2.0                                                    *
	***********************************************************************************/
	
	var Pool = function () {
	  /**
	  * @constructor
	  * @function constructor - Sets properties for this class
	  */
	  function Pool(hamsters) {
	    'use strict';
	
	    _classCallCheck(this, Pool);
	
	    this.hamsters = hamsters;
	    this.threads = [];
	    this.running = [];
	    this.pending = [];
	    this.fetchHamster = this.getAvailableThread.bind(this);
	  }
	
	  /**
	  * @function addWorkToPending - Adds task to queue waiting for available thread
	  * @param {number} index - Index of the task
	  * @param {object} task - Provided library functionality options for this task
	  * @param {function} resolve - onSuccess method
	  * @param {function} reject - onError method
	  */
	
	
	  _createClass(Pool, [{
	    key: 'addWorkToPending',
	    value: function addWorkToPending(index, hamsterFood, task, resolve, reject) {
	      if (this.hamsters.habitat.debug) {
	        task.scheduler.metrics.threads[task.scheduler.count].enqueued_at = Date.now();
	      }
	      this.pending.push({
	        index: index,
	        hamsterFood: hamsterFood,
	        task: task,
	        resolve: resolve,
	        reject: reject
	      });
	    }
	
	    /**
	    * @function processQueuedItem - Invokes processing of next item in queue
	    * @param {object} hamster - The thread to run the task
	    * @param {object} item - Task to process
	    */
	
	  }, {
	    key: 'processQueuedItem',
	    value: function processQueuedItem(hamster, item) {
	      if (this.hamsters.habitat.debug) {
	        item.task.scheduler.metrics.threads[item.index.id].dequeued_at = Date.now();
	      }
	      return this.runTask(hamster, item.index, item.hamsterFood, item.task, item.resolve, item.reject);
	    }
	
	    /**
	    * @function getAvailableThread - Gets an available thread
	    * @param {number} threadId - Id of the thread
	    * @returns {object} - The available thread
	    */
	
	  }, {
	    key: 'getAvailableThread',
	    value: function getAvailableThread(threadId) {
	      if (this.hamsters.habitat.persistence) {
	        return this.threads[threadId];
	      }
	      return this.spawnHamster();
	    }
	
	    /**
	    * @function keepTrackOfThread - Keeps track of threads running, scoped globally and to task
	    * @param {object} task - Provided library functionality options for this task
	    * @param {number} id - Id of thread to track
	    */
	
	  }, {
	    key: 'keepTrackOfThread',
	    value: function keepTrackOfThread(task, id) {
	      if (this.hamsters.habitat.debug) {
	        task.scheduler.metrics.threads[id].started_at = Date.now();
	      }
	      task.scheduler.workers.push(id);
	      this.running.push(id);
	    }
	
	    /**
	    * @function spawnHamsters - Spawns multiple new threads for execution
	    * @param {number} maxThreads - Max number of threads for this client
	    */
	
	  }, {
	    key: 'spawnHamsters',
	    value: function spawnHamsters(maxThreads) {
	      while (maxThreads--) {
	        this.threads.push(this.spawnHamster());
	      }
	    }
	
	    /**
	    * @function spawnHamster - Spawns a new thread for execution
	    * @return {object} - New WebWorker thread using selected scaffold
	    */
	
	  }, {
	    key: 'spawnHamster',
	    value: function spawnHamster() {
	      var _hamsters$habitat = this.hamsters.habitat,
	          selectHamsterWheel = _hamsters$habitat.selectHamsterWheel,
	          SharedWorker = _hamsters$habitat.SharedWorker,
	          Worker = _hamsters$habitat.Worker,
	          node = _hamsters$habitat.node,
	          parentPort = _hamsters$habitat.parentPort;
	
	      var hamsterWheel = selectHamsterWheel();
	      if (this.hamsters.habitat.webWorker) {
	        return new SharedWorker(hamsterWheel, 'SharedHamsterWheel');
	      }
	      if (node && typeof parentPort !== 'undefined') {
	        return new Worker(hamsterWheel);
	      }
	      return new Worker(hamsterWheel);
	    }
	
	    /**
	     * @function prepareMeal
	     * @description Prepares message to send to a thread and invoke execution
	     * @param {number} index - Index of the subarray to process
	     * @param {number} subTaskId - Subtask ID
	     * @param {object} task - Provided library functionality options for this task
	     * @returns {object} - Prepared message to send to a thread
	     */
	
	  }, {
	    key: 'prepareMeal',
	    value: function prepareMeal(index, subTaskId, task) {
	      index.id = subTaskId;
	
	      // Prepare the base hamsterFood object
	      var hamsterFood = {
	        array: task.input.array && task.input.array.length !== 0 ? this.hamsters.data.getSubArrayFromIndex(index, task) : [],
	        index: index
	      };
	
	      // Add sharedBuffer if it exists
	      if (typeof task.scheduler.sharedBuffer !== 'undefined') {
	        hamsterFood.sharedBuffer = task.scheduler.sharedBuffer;
	      }
	
	      // List of excluded keys
	      var excludedKeys = new Set(['array', 'threads', 'sharedArray']);
	
	      // Iterate over task.input properties and add to hamsterFood
	      for (var key in task.input) {
	        if (task.input.hasOwnProperty(key) && !excludedKeys.has(key)) {
	          hamsterFood[key] = task.input[key];
	        }
	      }
	
	      return hamsterFood;
	    }
	
	    /**
	    * @function runDistributedTask - Runs incoming distributed function using thread
	    * @param {object} incomingMessage - The incoming subTask object
	    */
	
	  }, {
	    key: 'runDistributedTask',
	    value: function runDistributedTask(incomingMessage, targetClient) {
	      var hamster = this.fetchHamster(this.running.length);
	      var task = incomingMessage.task;
	      var index = incomingMessage.hamsterFood.index;
	      task.input.targetClient = targetClient;
	      this.runTask(hamster, index, incomingMessage.hamsterFood, incomingMessage.task, incomingMessage.resolve, incomingMessage.reject);
	    }
	
	    /**
	    * @function runTask - Runs function using thread
	    * @param {object} hamster - The thread to run the task
	    * @param {number} index - Index of the subarray to process
	    * @param {object} task - Provided library functionality options for this task
	    * @param {function} resolve - onSuccess method
	    * @param {function} reject - onError method
	    */
	
	  }, {
	    key: 'runTask',
	    value: function runTask(hamster, index, hamsterFood, task, resolve, reject) {
	      var threadId = this.running.length;
	      this.hamsters.pool.keepTrackOfThread(task, threadId);
	      if (this.hamsters.habitat.legacy) {
	        this.hamsters.wheel.legacy(hamsterFood, resolve, reject);
	      } else {
	        this.hamsters.pool.trainHamster(index, task, threadId, hamster, resolve, reject);
	        this.hamsters.data.feedHamster(hamster, hamsterFood);
	      }
	      task.scheduler.count += 1;
	    }
	
	    /**
	    * @function hamsterWheel - Runs or queues function using threads
	    * @param {number} index - Index of the subarray to process
	    * @param {object} task - Provided library functionality options for this task
	    * @param {function} resolve - onSuccess method
	    * @param {function} reject - onError method
	    */
	
	  }, {
	    key: 'hamsterWheel',
	    value: function hamsterWheel(index, subTaskId, task, resolve, reject) {
	      var hamsterFood = this.prepareMeal(index, subTaskId, task);
	      if (this.hamsters.habitat.maxThreads <= this.running.length) {
	        this.addWorkToPending(index, hamsterFood, task, resolve, reject);
	      } else {
	        if (task.input.distribute) {
	          this.hamsters.distribute.distributeTask(task, hamsterFood, resolve, reject);
	        } else {
	          var hamster = this.fetchHamster(this.running.length);
	          this.runTask(hamster, index, hamsterFood, task, resolve, reject);
	        }
	      }
	    }
	
	    /**
	    * @function returnOutputAndRemoveTask - Gathers thread outputs into final result
	    * @param {object} task - Provided library functionality options for this task
	    * @param {function} resolve - onSuccess method
	    */
	
	  }, {
	    key: 'returnOutputAndRemoveTask',
	    value: function returnOutputAndRemoveTask(task, resolve) {
	      if (task.input.sharedArray) {
	        task.output = hamsters.data.processDataType(task.input.dataType, task.scheduler.sharedBuffer);
	      }
	      if (task.input.aggregate) {
	        task.output = this.hamsters.data.aggregateThreadOutputs(task.output, task.input.dataType);
	      }
	      if (task.input.sort) {
	        task.output = this.hamsters.data.sortOutput(task.output, task.input.sort);
	      }
	      if (this.hamsters.habitat.debug) {
	        task.scheduler.metrics.completed_at = Date.now();
	        console.info("Hamsters.js Task Completed: ", task);
	      }
	      if (task.input.distribute) {
	        this.hamsters.distribute.sendDataResponse(task.input.targetClient, task, true);
	      } else {
	        resolve(task.output);
	      }
	    }
	
	    /**
	    * @function removeFromRunning - Removes a thread from the running pool
	    * @param {object} task - Provided library functionality options for this task
	    * @param {number} threadId - Id of the thread to remove
	    */
	
	  }, {
	    key: 'removeFromRunning',
	    value: function removeFromRunning(task, threadId) {
	      this.running.splice(this.running.indexOf(threadId), 1);
	      task.scheduler.workers.splice(task.scheduler.workers.indexOf(threadId), 1);
	    }
	
	    /**
	     * @function processReturn - Processes the returned message from a thread
	     * @param {number} index - Index of the subarray processed
	     * @param {object} message - Message returned from the thread
	     * @param {object} task - Provided library functionality options for this task
	     */
	
	  }, {
	    key: 'processReturn',
	    value: function processReturn(index, message, task) {
	      var isReactNative = this.hamsters.habitat.reactNative;
	      var isNode = this.hamsters.habitat.node;
	      var response = message.data;
	      var messageData = isReactNative ? JSON.parse(message).data : response.data !== undefined ? response.data : response;
	      var threadId = isNode ? message.index.id : response.index.id;
	
	      if (task.scheduler.threads !== 1) {
	        if (isReactNative || task.input.mixedOutput) {
	          task.output[threadId] = messageData;
	        } else {
	          this.hamsters.data.addThreadOutputWithIndex(task, index, messageData);
	        }
	      } else {
	        task.output = messageData;
	      }
	    }
	
	    /**
	    * @function setOnMessage - Sets the message handlers for a thread
	    * @param {object} hamster - The thread to set the handlers on
	    * @param {function} onThreadResponse - Handler for thread response
	    * @param {object} habitat - Habitat configuration
	    * @param {function} reject - onError method
	    */
	
	  }, {
	    key: 'setOnMessage',
	    value: function setOnMessage(hamster, onThreadResponse, reject) {
	      if (this.hamsters.habitat.webWorker) {
	        hamster.port.onmessage = onThreadResponse;
	        hamster.port.onmessageerror = reject;
	        hamster.port.onerror = reject;
	      } else if (this.hamsters.habitat.node) {
	        hamster.once('message', onThreadResponse);
	        hamster.once('onmessageerror', reject);
	        hamster.once('error', reject);
	      } else {
	        hamster.onmessage = onThreadResponse;
	        hamster.onmessageerror = reject;
	        hamster.onerror = reject;
	      }
	    }
	
	    /**
	    * @function trainHamster - Trains thread in how to behave
	    * @param {number} index - Index of the subarray to process
	    * @param {object} task - Provided library functionality options for this task
	    * @param {number} threadId - Id of the thread to train
	    * @param {object} hamster - The thread to train
	    * @param {function} resolve - onSuccess method
	    * @param {function} reject - onError method
	    */
	
	  }, {
	    key: 'trainHamster',
	    value: function trainHamster(index, task, threadId, hamster, resolve, reject) {
	      var _this = this;
	
	      var onThreadResponse = function onThreadResponse(message) {
	        _this.hamsters.pool.processReturn(index, message, task);
	        if (_this.hamsters.habitat.debug) {
	          task.scheduler.metrics.threads[threadId].completed_at = Date.now();
	        }
	        _this.hamsters.pool.removeFromRunning(task, threadId);
	        if (task.scheduler.workers.length === 0 && task.scheduler.count === task.scheduler.threads) {
	          _this.hamsters.pool.returnOutputAndRemoveTask(task, resolve);
	        }
	        if (_this.hamsters.pool.pending.length !== 0) {
	          _this.hamsters.pool.processQueuedItem(hamster, _this.hamsters.pool.pending.shift());
	        } else if (!_this.hamsters.habitat.persistence) {
	          hamster.terminate();
	        }
	      };
	      this.hamsters.pool.setOnMessage(hamster, onThreadResponse, reject);
	    }
	
	    /**
	    * @function scheduleTask - Adds new task to the system for execution
	    * @param {object} task - Provided library functionality options for this task
	    */
	
	  }, {
	    key: 'scheduleTask',
	    value: function scheduleTask(task) {
	      var _this2 = this;
	
	      var i = 0;
	      if (this.hamsters.habitat.debug) {
	        var metrics = task.scheduler.metrics;
	        metrics.started_at = Date.now();
	        return new Promise(function (resolve, reject) {
	          while (i < task.scheduler.threads) {
	            metrics.threads.push({
	              created_at: Date.now(),
	              started_at: null,
	              enqueued_at: null,
	              dequeued_at: null,
	              completed_at: null
	            });
	            _this2.hamsterWheel(task.scheduler.indexes[i], i, task, resolve, reject);
	            i += 1;
	          }
	        });
	      }
	      //Process with debug mode disabled, no need for time stamping
	      return new Promise(function (resolve, reject) {
	        while (i < task.scheduler.threads) {
	          _this2.hamsterWheel(task.scheduler.indexes[i], i, task, resolve, reject);
	          i += 1;
	        }
	      });
	    }
	  }]);
	
	  return Pool;
	}();
	
	module.exports = Pool;

/***/ }),
/* 4 */
/***/ (function(module, exports) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Data = function () {
	
	  /**
	  * @constructor
	  * @function constructor - Sets properties for this class
	  */
	  function Data(hamsters) {
	    'use strict';
	
	    _classCallCheck(this, Data);
	
	    this.hamsters = hamsters; // Set the hamsters object as a property of Data class
	    this.getSubArrayFromIndex = this.getSubArrayUsingIndex.bind(this); // Bind getSubArrayUsingIndex function
	    this.getSubArrayIndexes = this.calculateIndexes.bind(this); // Bind calculateIndexes function
	    this.sortOutput = this.sortTaskOutput.bind(this); // Bind sortTaskOutput function
	    this.aggregateThreadOutputs = this.aggregateThreadOutputs.bind(this);
	    this.processDataType = this.typedArrayFromBuffer;
	    this.prepareFunction = this.prepareWorkerTask.bind(this); // Bind prepareWorkerTask function
	    this.feedHamster = this.messageWorkerThread.bind(this); // Bind messageWorkerThread function
	    this.getBufferSize = this.getBufferSize;
	    this.createSharedBuffer = this.createSharedBuffer.bind(this);
	    this.getDataType = this.getDataType;
	    this.setupSharedArrayBuffer = this.setupSharedArrayBuffer.bind(this);
	  }
	
	  /**
	  * @function messageWorkerThread - Prepares message to send to thread
	  * @param {object} hamstersHabitat - Hamsters Habitat instance
	  * @param {Worker} hamster - Thread to message
	  * @param {object} hamsterFood - Message to send to thread
	  */
	
	
	  _createClass(Data, [{
	    key: 'messageWorkerThread',
	    value: function messageWorkerThread(hamster, hamsterFood) {
	      if (this.hamsters.habitat.reactNative) {
	        return hamster.postMessage(JSON.stringify(hamsterFood));
	      }
	      if (this.hamsters.habitat.webWorker) {
	        return hamster.port.postMessage(hamsterFood);
	      }
	      return hamster.postMessage(hamsterFood, this.hamsters.data.getTransferableObjects(hamsterFood));
	    }
	  }, {
	    key: 'getTransferableObjects',
	    value: function getTransferableObjects(obj) {
	      var typedArrayBuffers = [];
	      var transferableObjects = [];
	      var typedArrayTypes = ['Int32Array', 'Uint8Array', 'Uint8ClampedArray', 'Int16Array', 'Uint16Array', 'Uint32Array', 'Float32Array', 'Float64Array'];
	      var otherTransferables = ['ArrayBuffer', 'MessagePort', 'ImageBitmap', 'OffscreenCanvas'];
	      var globalContext = typeof window !== 'undefined' ? window : global;
	
	      for (var prop in obj) {
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;
	
	        try {
	          for (var _iterator = typedArrayTypes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var type = _step.value;
	
	            if (typeof globalContext[type] !== 'undefined' && obj[prop] instanceof globalContext[type]) {
	              typedArrayBuffers.push(obj[prop].buffer);
	              break;
	            }
	          }
	        } catch (err) {
	          _didIteratorError = true;
	          _iteratorError = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	              _iterator.return();
	            }
	          } finally {
	            if (_didIteratorError) {
	              throw _iteratorError;
	            }
	          }
	        }
	
	        var _iteratorNormalCompletion2 = true;
	        var _didIteratorError2 = false;
	        var _iteratorError2 = undefined;
	
	        try {
	          for (var _iterator2 = otherTransferables[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	            var _type = _step2.value;
	
	            if (typeof globalContext[_type] !== 'undefined' && obj[prop] instanceof globalContext[_type]) {
	              transferableObjects.push(obj[prop]);
	              break;
	            }
	          }
	        } catch (err) {
	          _didIteratorError2 = true;
	          _iteratorError2 = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion2 && _iterator2.return) {
	              _iterator2.return();
	            }
	          } finally {
	            if (_didIteratorError2) {
	              throw _iteratorError2;
	            }
	          }
	        }
	      }
	
	      return typedArrayBuffers.concat(transferableObjects);
	    }
	
	    /**
	    * @function typedArrayFromBuffer - Converts buffer into new typed array
	    * @param {string} dataType - Typed array type for this task
	    * @param {object} buffer - Buffer to convert
	    */
	
	  }, {
	    key: 'typedArrayFromBuffer',
	    value: function typedArrayFromBuffer(dataType, buffer) {
	      var types = {
	        'Uint32': Uint32Array,
	        'Uint16': Uint16Array,
	        'Uint8': Uint8Array,
	        'Uint8clamped': Uint8ClampedArray,
	        'Int32': Int32Array,
	        'Int16': Int16Array,
	        'Int8': Int8Array,
	        'Float32': Float32Array,
	        'Float64': Float64Array
	      };
	      if (!types[dataType]) {
	        return buffer;
	      }
	      return new types[dataType](buffer);
	    }
	
	    /**
	    * @function prepareWorkerTask - Prepares function for thread, strips whitespace
	    * @param {function} functionBody - Message to send to thread
	    */
	
	  }, {
	    key: 'prepareWorkerTask',
	    value: function prepareWorkerTask(functionBody) {
	      var functionString = String(functionBody);
	      return functionString.substring(functionString.indexOf("{") + 1, functionString.length - 1);
	    }
	
	    /**
	    * @function sortTaskOutput - Sorts array by defined order
	    * @param {object} arr - Array to sort
	    * @param {string} order - Defined sort order
	    */
	
	  }, {
	    key: 'sortTaskOutput',
	    value: function sortTaskOutput(arr, order) {
	      switch (order) {
	        case 'desc':
	        case 'asc':
	          return Array.prototype.sort.call(arr, function (a, b) {
	            return order === 'asc' ? a - b : b - a;
	          });
	        case 'ascAlpha':
	          return arr.sort();
	        case 'descAlpha':
	          return arr.reverse();
	        default:
	          return arr;
	      }
	    }
	
	    /**
	     * @function getBufferSize - Gets the byte length of the input array
	     * @param {TypedArray} array - The input typed array
	     * @returns {number} - The byte length of the array
	     */
	
	  }, {
	    key: 'getBufferSize',
	    value: function getBufferSize(array) {
	      return array.byteLength;
	    }
	
	    /**
	     * @function createSharedBuffer - Creates a SharedArrayBuffer based on the input array's byte length
	     * @param {TypedArray} array - The input typed array
	     * @returns {SharedArrayBuffer} - The created SharedArrayBuffer
	     */
	
	  }, {
	    key: 'createSharedBuffer',
	    value: function createSharedBuffer(array) {
	      var byteLength = this.getBufferSize(array);
	      var sharedBuffer = new SharedArrayBuffer(byteLength);
	      var sharedArray = new array.constructor(sharedBuffer);
	
	      // Copy data from the input array to the shared array
	      sharedArray.set(array);
	
	      return sharedBuffer;
	    }
	
	    /**
	     * @function setupSharedArrayBuffer - Sets up the shared buffer and corresponding typed array
	     * @param {TypedArray} array - The input typed array
	     * @returns {object} - SharedArrayBuffer;
	     */
	
	  }, {
	    key: 'setupSharedArrayBuffer',
	    value: function setupSharedArrayBuffer(array) {
	      return this.createSharedBuffer(array);
	    }
	
	    /**
	    * @function aggregateThreadOutputs - Joins individual thread outputs into single result
	    * @param {array} input - Array of arrays to aggregate
	    * @param {string} dataType - Data type to use for typed array
	    */
	
	  }, {
	    key: 'aggregateThreadOutputs',
	    value: function aggregateThreadOutputs(input, dataType) {
	      if (!dataType) {
	        return input.reduce(function (a, b) {
	          return a.concat(b);
	        });
	      }
	      var i = 0;
	      var len = input.length;
	      var bufferLength = 0;
	      for (i; i < len; i += 1) {
	        bufferLength += input[i].length;
	      }
	      var output = this.processDataType(dataType, bufferLength);
	      var offset = 0;
	      for (i = 0; i < len; i += 1) {
	        output.set(input[i], offset);
	        offset += input[i].length;
	      }
	      return output;
	    }
	
	    /**
	    * @function addThreadOutputWithIndex - Joins individual thread outputs into single result
	    * @param {object} task - Hamsters task object
	    * @param {object} index - Index information
	    * @param {array} output - Output array
	    */
	
	  }, {
	    key: 'addThreadOutputWithIndex',
	    value: function addThreadOutputWithIndex(task, index, output) {
	      var i = 0;
	      var outputLength = output.length;
	      for (i; i < outputLength; i++) {
	        task.output[index.start + i] = output[i];
	      }
	    }
	
	    /**
	     * @function calculateIndexes - Splits a single array into multiple equal sized subarrays
	     * @param {array} array - Array to split
	     * @param {number} n - Number of subarrays to create
	     */
	
	  }, {
	    key: 'calculateIndexes',
	    value: function calculateIndexes(array, n) {
	      // If n is 1, return the whole array range
	      if (n === 1) {
	        return [{ start: 0, end: array.length - 1 }];
	      }
	
	      var indexes = [];
	      var segmentSize = Math.floor(array.length / n);
	      var startIndex = 0;
	
	      for (var i = 0; i < n; i++) {
	        var endIndex = startIndex + segmentSize - 1;
	        indexes.push({ start: startIndex, end: endIndex });
	        startIndex = endIndex + 1;
	      }
	
	      // Adjust the last segment to cover any remaining elements
	      if (startIndex < array.length) {
	        indexes[n - 1].end = array.length - 1;
	      }
	
	      return indexes;
	    }
	
	    /**
	    * @function getSubArrayUsingIndex - Slices subarray based on provided index
	    * @param {object} index - Index information
	    * @param {object} task - Hamsters task object
	    */
	
	  }, {
	    key: 'getSubArrayUsingIndex',
	    value: function getSubArrayUsingIndex(index, task) {
	      return task.input.array.slice(index.start, index.end + 1);
	    }
	  }]);
	
	  return Data;
	}();
	
	module.exports = Data;

/***/ }),
/* 5 */
/***/ (function(module, exports) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Wheel = function () {
	
	  /**
	  * @constructor
	  * @function constructor - Sets properties for this class
	  */
	  function Wheel(hamsters) {
	    'use strict';
	
	    _classCallCheck(this, Wheel);
	
	    this.hamsters = hamsters;
	    this.worker = this.workerScaffold;
	    this.regular = this.regularScaffold;
	    this.legacy = this.legacyScaffold.bind(this);
	  }
	
	  /**
	  * @function workerScaffold - Provides worker body for library functionality when used within a worker [threads inside threads]
	  */
	
	
	  _createClass(Wheel, [{
	    key: 'workerScaffold',
	    value: function workerScaffold() {
	      var _this = this;
	
	      self.params = {};
	      self.rtn = {};
	
	      addEventListener('connect', function (incomingConnection) {
	        var port = incomingConnection.ports[0];
	        port.start();
	        port.addEventListener('message', function (incomingMessage) {
	          _this.params = incomingMessage.data;
	          _this.rtn = {
	            data: [],
	            dataType: _this.params.dataType
	          };
	          eval("(" + _this.params.hamstersJob + ")")();
	          port.postMessage(_this.rtn);
	        }, false);
	      }, false);
	    }
	
	    /**
	     * @function regularScaffold - Provides worker body for library functionality
	     */
	
	  }, {
	    key: 'regularScaffold',
	    value: function regularScaffold() {
	      self.params = {};
	      self.rtn = {};
	
	      self.onmessage = function (message) {
	        this.params = message.data;
	        this.rtn = {
	          data: [],
	          dataType: typeof this.params.dataType !== 'undefined' ? this.params.dataType : null,
	          index: this.params.index
	        };
	        if (this.params.sharedBuffer) {
	          this.params.sharedArray = typedArrayFromBuffer(this.params.dataType, this.params.sharedBuffer);
	        }
	        eval(this.params.hamstersJob);
	        var buffers = handleDataType(this.rtn);
	        returnResponse(this.rtn, buffers);
	      }.bind(this);
	
	      function handleDataType(rtn) {
	        if (this.params.sharedArray) {
	          // Do nothing here, we don't need to return a buffer rtn.data is useless here
	        } else if (this.params.dataType) {
	          rtn.data = typedArrayFromBuffer(rtn.dataType, rtn.data);
	        }
	        return getTransferableObjects(rtn); // Return transferable objects
	      }
	
	      function typedArrayFromBuffer(dataType, buffer) {
	        var types = {
	          'Uint32': Uint32Array,
	          'Uint16': Uint16Array,
	          'Uint8': Uint8Array,
	          'Uint8clamped': Uint8ClampedArray,
	          'Int32': Int32Array,
	          'Int16': Int16Array,
	          'Int8': Int8Array,
	          'Float32': Float32Array,
	          'Float64': Float64Array
	        };
	        if (!types[dataType]) {
	          return buffer;
	        }
	        return new types[dataType](buffer);
	      }
	
	      function returnResponse(rtn, buffers) {
	        if (buffers && buffers.length > 0) {
	          // If there are buffers, postMessage with transferable objects
	          postMessage(rtn, buffers);
	        } else {
	          // Otherwise, postMessage without transferable objects
	          postMessage(rtn);
	        }
	      }
	
	      function getTransferableObjects(obj) {
	        var typedArrayBuffers = [];
	        var transferableObjects = [];
	        var typedArrayTypes = ['Int32Array', 'Uint8Array', 'Uint8ClampedArray', 'Int16Array', 'Uint16Array', 'Uint32Array', 'Float32Array', 'Float64Array'];
	        var otherTransferables = ['ArrayBuffer', 'MessagePort', 'ImageBitmap', 'OffscreenCanvas'];
	
	        var globalContext = typeof self !== 'undefined' ? self : window;
	
	        for (var prop in obj) {
	          var _iteratorNormalCompletion = true;
	          var _didIteratorError = false;
	          var _iteratorError = undefined;
	
	          try {
	            for (var _iterator = typedArrayTypes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	              var type = _step.value;
	
	              if (typeof globalContext[type] !== 'undefined' && obj[prop] instanceof globalContext[type]) {
	                typedArrayBuffers.push(obj[prop].buffer);
	                break;
	              }
	            }
	          } catch (err) {
	            _didIteratorError = true;
	            _iteratorError = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	              }
	            } finally {
	              if (_didIteratorError) {
	                throw _iteratorError;
	              }
	            }
	          }
	
	          var _iteratorNormalCompletion2 = true;
	          var _didIteratorError2 = false;
	          var _iteratorError2 = undefined;
	
	          try {
	            for (var _iterator2 = otherTransferables[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	              var _type = _step2.value;
	
	              if (typeof globalContext[_type] !== 'undefined' && obj[prop] instanceof globalContext[_type]) {
	                transferableObjects.push(obj[prop]);
	                break;
	              }
	            }
	          } catch (err) {
	            _didIteratorError2 = true;
	            _iteratorError2 = err;
	          } finally {
	            try {
	              if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                _iterator2.return();
	              }
	            } finally {
	              if (_didIteratorError2) {
	                throw _iteratorError2;
	              }
	            }
	          }
	        }
	
	        return typedArrayBuffers.concat(transferableObjects);
	      }
	    }
	
	    /**
	    * @function legacyScaffold - Provides library functionality for legacy devices
	    */
	
	  }, {
	    key: 'legacyScaffold',
	    value: function legacyScaffold(params, resolve, reject) {
	      var rtn = {
	        data: [],
	        dataType: typeof params.dataType !== "undefined" ? params.dataType : null
	      };
	      if (this.hamsters.habitat.reactNative) {
	        self.rtn = rtn;
	      }
	      if (this.hamsters.habitat.node || this.hamsters.habitat.isIE) {
	        eval(params.hamstersJob);
	      } else {
	        params.hamstersJob();
	      }
	      resolve(rtn.data);
	    }
	  }]);
	
	  return Wheel;
	}();
	
	module.exports = Wheel;

/***/ }),
/* 6 */
/***/ (function(module, exports) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/**
	 * @class HamstersTask
	 * @classdesc Constructs a new task object from provided arguments for Hamsters.js
	 */
	var Task = function () {
	  /**
	   * @constructor
	   * @param {object} habitat - The environment settings
	   * @param {object} data - Data utility methods
	   * @param {object} params - Provided library execution options
	   * @param {function} functionToRun - Function to execute
	   */
	  function Task(hamsters, params, functionToRun) {
	    'use strict';
	
	    _classCallCheck(this, Task);
	
	    this.input = params;
	    this.output = [];
	    this.scheduler = {
	      count: 0,
	      threads: params.threads || 1,
	      workers: []
	    };
	
	    if (hamsters.habitat.legacy) {
	      this.setupLegacyTask(hamsters, functionToRun);
	    } else {
	      this.setupModernTask(hamsters, params, functionToRun);
	    }
	
	    if (hamsters.habitat.debug) {
	      this.setupDebugMetrics();
	    }
	  }
	
	  /**
	   * @method setupLegacyTask
	   * @description Sets up task for legacy environments
	   * @param {function} functionToRun - Function to execute
	   */
	
	
	  _createClass(Task, [{
	    key: 'setupLegacyTask',
	    value: function setupLegacyTask(hamsters, functionToRun) {
	      this.scheduler.threads = 1;
	      if (!hamsters.habitat.node && !hamsters.habitat.isIE) {
	        this.input.hamstersJob = functionToRun;
	      }
	    }
	
	    /**
	     * @method setupModernTask
	     * @description Sets up task for modern environments
	     * @param {object} params - Provided library execution options
	     * @param {function} functionToRun - Function to execute
	     */
	
	  }, {
	    key: 'setupModernTask',
	    value: function setupModernTask(hamsters, params, functionToRun) {
	      this.input.hamstersJob = hamsters.habitat.legacy ? functionToRun : hamsters.data.prepareFunction(functionToRun);
	      if (params.sharedArray && hamsters.habitat.atomics) {
	        this.scheduler.indexes = params.indexes || hamsters.data.getSubArrayIndexes(params.sharedArray, this.scheduler.threads);
	        this.scheduler.sharedBuffer = hamsters.data.setupSharedArrayBuffer(params.sharedArray);
	      } else {
	        this.scheduler.indexes = params.indexes || hamsters.data.getSubArrayIndexes(params.array, this.scheduler.threads);
	      }
	    }
	
	    /**
	     * @method setupDebugMetrics
	     * @description Sets up debug metrics if debug mode is enabled
	     */
	
	  }, {
	    key: 'setupDebugMetrics',
	    value: function setupDebugMetrics() {
	      this.scheduler.metrics = {
	        created_at: Date.now(),
	        started_at: null,
	        completed_at: null,
	        threads: []
	      };
	    }
	  }]);
	
	  return Task;
	}();
	
	module.exports = Task;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	var _NodeStore = __webpack_require__(8);
	
	var _NodeStore2 = _interopRequireDefault(_NodeStore);
	
	var _WebStore = __webpack_require__(9);
	
	var _WebStore2 = _interopRequireDefault(_WebStore);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Memoize = function () {
	    function Memoize(hamsters, maxSize) {
	        'use strict';
	
	        _classCallCheck(this, Memoize);
	
	        this.hamsters = hamsters;
	        this.store = this.hamsters.habitat.node ? new _NodeStore2.default(maxSize) : new _WebStore2.default('hamstersjs', 'cacheStore', maxSize);
	    }
	
	    _createClass(Memoize, [{
	        key: 'memoize',
	        value: function memoize(func) {
	            var self = this;
	            return function (task) {
	                var key = self.generateTaskKey(task);
	
	                return new Promise(function (resolve, reject) {
	                    self.store.get(key).then(function (cachedResult) {
	                        if (cachedResult !== null) {
	                            resolve(cachedResult);
	                        } else {
	                            self.applyFunc(func, task).then(function (result) {
	                                self.store.set(key, result).then(function () {
	                                    resolve(result);
	                                }).catch(reject);
	                            }).catch(reject);
	                        }
	                    }).catch(reject);
	                });
	            };
	        }
	    }, {
	        key: 'generateTaskKey',
	        value: function generateTaskKey(task) {
	            var key = JSON.stringify({ input: task.input });
	            return this.hashCode(key);
	        }
	    }, {
	        key: 'hashCode',
	        value: function hashCode(str) {
	            var hash = 0,
	                i = void 0,
	                chr = void 0;
	            if (str.length === 0) return hash;
	            for (i = 0; i < str.length; i++) {
	                chr = str.charCodeAt(i);
	                hash = (hash << 5) - hash + chr;
	                hash |= 0; // Convert to 32bit integer
	            }
	            return hash.toString();
	        }
	    }, {
	        key: 'applyFunc',
	        value: function applyFunc(func, args) {
	            return new Promise(function (resolve, reject) {
	                try {
	                    var result = func.apply(null, args);
	                    resolve(result);
	                } catch (error) {
	                    reject(error);
	                }
	            });
	        }
	    }]);
	
	    return Memoize;
	}();
	
	module.exports = Memoize;

/***/ }),
/* 8 */
/***/ (function(module, exports) {

	"use strict";
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var NodeStore = function () {
	    function NodeStore(maxSize) {
	        _classCallCheck(this, NodeStore);
	
	        this.maxSize = maxSize;
	        this.cache = new Map();
	    }
	
	    _createClass(NodeStore, [{
	        key: "get",
	        value: function get(key) {
	            if (this.cache.has(key)) {
	                var value = this.cache.get(key);
	                // Refresh the key
	                this.cache.delete(key);
	                this.cache.set(key, value);
	                return Promise.resolve(value);
	            }
	            return Promise.resolve(null);
	        }
	    }, {
	        key: "set",
	        value: function set(key, value) {
	            if (this.cache.size >= this.maxSize) {
	                // Remove the oldest (least recently used) entry
	                var oldestKey = this.cache.keys().next().value;
	                this.cache.delete(oldestKey);
	            }
	            this.cache.set(key, value);
	            return Promise.resolve();
	        }
	    }, {
	        key: "clear",
	        value: function clear() {
	            this.cache.clear();
	            return Promise.resolve();
	        }
	    }]);
	
	    return NodeStore;
	}();
	
	module.exports = NodeStore;

/***/ }),
/* 9 */
/***/ (function(module, exports) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var WebStore = function () {
	    function WebStore(dbName, storeName, maxSize) {
	        _classCallCheck(this, WebStore);
	
	        this.dbName = dbName;
	        this.storeName = storeName;
	        this.maxSize = maxSize;
	        this.db = null;
	        this.initDB();
	    }
	
	    _createClass(WebStore, [{
	        key: 'initDB',
	        value: function initDB() {
	            var self = this;
	            var request = indexedDB.open(this.dbName, 1);
	
	            request.onerror = function (event) {
	                console.error('Error opening database:', event.target.error);
	            };
	
	            request.onupgradeneeded = function (event) {
	                var db = event.target.result;
	                if (!db.objectStoreNames.contains(self.storeName)) {
	                    var objectStore = db.createObjectStore(self.storeName, { keyPath: 'key' });
	                    objectStore.createIndex('by_key', 'key', { unique: true });
	                    objectStore.createIndex('by_timestamp', 'timestamp');
	                }
	            };
	
	            request.onsuccess = function (event) {
	                self.db = event.target.result;
	            };
	        }
	    }, {
	        key: 'get',
	        value: function get(key) {
	            var self = this;
	            return new Promise(function (resolve, reject) {
	                if (!self.db) {
	                    console.error('Database not initialized');
	                    resolve(null);
	                    return;
	                }
	
	                var transaction = self.db.transaction([self.storeName], 'readonly');
	                var objectStore = transaction.objectStore(self.storeName);
	                var request = objectStore.get(key);
	
	                request.onsuccess = function (event) {
	                    var result = event.target.result;
	                    if (result) {
	                        self.updateTimestamp(key).then(function () {
	                            return resolve(result.value);
	                        }).catch(reject);
	                    } else {
	                        resolve(null);
	                    }
	                };
	
	                request.onerror = function (event) {
	                    reject(event.target.error);
	                };
	            });
	        }
	    }, {
	        key: 'set',
	        value: function set(key, value) {
	            var self = this;
	            return new Promise(function (resolve, reject) {
	                if (!self.db) {
	                    console.error('Database not initialized');
	                    resolve();
	                    return;
	                }
	
	                self.checkSize().then(function () {
	                    var transaction = self.db.transaction([self.storeName], 'readwrite');
	                    var objectStore = transaction.objectStore(self.storeName);
	                    var request = objectStore.put({ key: key, value: value, timestamp: Date.now() });
	
	                    request.onsuccess = function () {
	                        resolve();
	                    };
	
	                    request.onerror = function (event) {
	                        reject(event.target.error);
	                    };
	                }).catch(reject);
	            });
	        }
	    }, {
	        key: 'clear',
	        value: function clear() {
	            var self = this;
	            return new Promise(function (resolve, reject) {
	                if (!self.db) {
	                    console.error('Database not initialized');
	                    resolve();
	                    return;
	                }
	
	                var transaction = self.db.transaction([self.storeName], 'readwrite');
	                var objectStore = transaction.objectStore(self.storeName);
	                var request = objectStore.clear();
	
	                request.onsuccess = function () {
	                    resolve();
	                };
	
	                request.onerror = function (event) {
	                    reject(event.target.error);
	                };
	            });
	        }
	    }, {
	        key: 'checkSize',
	        value: function checkSize() {
	            var self = this;
	            return new Promise(function (resolve, reject) {
	                var transaction = self.db.transaction([self.storeName], 'readonly');
	                var objectStore = transaction.objectStore(self.storeName);
	                var countRequest = objectStore.count();
	
	                countRequest.onsuccess = function () {
	                    var count = countRequest.result;
	                    if (count >= self.maxSize) {
	                        self.evictOldest().then(resolve).catch(reject);
	                    } else {
	                        resolve();
	                    }
	                };
	
	                countRequest.onerror = function (event) {
	                    reject(event.target.error);
	                };
	            });
	        }
	    }, {
	        key: 'evictOldest',
	        value: function evictOldest() {
	            var self = this;
	            return new Promise(function (resolve, reject) {
	                var transaction = self.db.transaction([self.storeName], 'readwrite');
	                var objectStore = transaction.objectStore(self.storeName);
	                var index = objectStore.index('by_timestamp');
	                var request = index.openCursor(null, 'next');
	
	                request.onsuccess = function (event) {
	                    var cursor = event.target.result;
	                    if (cursor) {
	                        cursor.delete().onsuccess = function () {
	                            resolve();
	                        };
	                    } else {
	                        resolve();
	                    }
	                };
	
	                request.onerror = function (event) {
	                    reject(event.target.error);
	                };
	            });
	        }
	    }, {
	        key: 'updateTimestamp',
	        value: function updateTimestamp(key) {
	            var self = this;
	            return new Promise(function (resolve, reject) {
	                var transaction = self.db.transaction([self.storeName], 'readwrite');
	                var objectStore = transaction.objectStore(self.storeName);
	                var request = objectStore.get(key);
	
	                request.onsuccess = function (event) {
	                    var data = event.target.result;
	                    if (data) {
	                        data.timestamp = Date.now();
	                        objectStore.put(data).onsuccess = function () {
	                            resolve();
	                        };
	                    } else {
	                        resolve();
	                    }
	                };
	
	                request.onerror = function (event) {
	                    reject(event.target.error);
	                };
	            });
	        }
	    }]);
	
	    return WebStore;
	}();
	
	module.exports = WebStore;

/***/ }),
/* 10 */
/***/ (function(module, exports) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Distribute = function () {
	  function Distribute(hamsters) {
	    'use strict';
	
	    _classCallCheck(this, Distribute);
	
	    this.hamsters = hamsters;
	    this.localConnection = null;
	    this.remoteConnections = {};
	    this.sendChannels = {}; // Stores outgoing data channels
	    this.receiveChannels = {}; // Stores incoming data channels
	    this.pcConstraint = null;
	    this.dataConstraint = null;
	    this.ws = null;
	    this.connectionTargets = []; // List of clients to connect to
	    this.clientId = null; // Current client ID
	
	    // Initialize WebSocket connection
	    this.initWebSocket();
	  }
	
	  _createClass(Distribute, [{
	    key: 'initWebSocket',
	    value: function initWebSocket() {
	      var _this = this;
	
	      this.ws = new WebSocket('ws://' + window.location.host);
	
	      this.ws.onopen = function () {
	        console.log('WebSocket connection established');
	      };
	
	      this.ws.onmessage = function (event) {
	        var message = JSON.parse(event.data);
	        switch (message.type) {
	          case 'register':
	            _this.clientId = message.id;
	            _this.loadClientList();
	            break;
	          case 'update-client-list':
	            _this.updateClientList(message.clients);
	            break;
	          case 'offer':
	            _this.handleOffer(message);
	            break;
	          case 'answer':
	            _this.handleAnswer(message);
	            break;
	          case 'candidate':
	            _this.handleCandidate(message);
	            break;
	          default:
	            console.log('Unknown message type:', message.type);
	        }
	      };
	
	      this.ws.onerror = function (error) {
	        console.error('WebSocket error:', error);
	      };
	
	      this.ws.onclose = function () {
	        console.log('WebSocket connection closed');
	      };
	    }
	  }, {
	    key: 'updateClientList',
	    value: function updateClientList(clients) {
	      this.connectionTargets = clients.map(function (client) {
	        return client.id;
	      });
	    }
	  }, {
	    key: 'loadClientList',
	    value: function loadClientList() {
	      var _this2 = this;
	
	      fetch('/clients?currentId=' + this.clientId).then(function (response) {
	        return response.json();
	      }).then(function (data) {
	        _this2.connectionTargets = data.map(function (client) {
	          return client.id;
	        });
	        _this2.createConnection(); // Automatically create connections after fetching client list
	      }).catch(function (error) {
	        return console.error('Error fetching client list:', error);
	      });
	    }
	  }, {
	    key: 'createConnection',
	    value: function createConnection() {
	      var _this3 = this;
	
	      if (!this.connectionTargets.length) {
	        return alert('No clients to connect to.');
	      }
	
	      var servers = null;
	
	      this.connectionTargets.forEach(function (targetClient) {
	        if (!_this3.remoteConnections[targetClient]) {
	          var localConnection = new RTCPeerConnection(servers, _this3.pcConstraint);
	          var sendChannel = localConnection.createDataChannel('hamstersjs', _this3.dataConstraint);
	
	          localConnection.onicecandidate = function (e) {
	            if (e.candidate) {
	              _this3.ws.send(JSON.stringify({ type: 'candidate', target: targetClient, candidate: e.candidate }));
	            }
	          };
	
	          sendChannel.onopen = function () {
	            _this3.onSendChannelStateChange();
	          };
	          sendChannel.onclose = _this3.onSendChannelStateChange.bind(_this3);
	
	          sendChannel.onmessage = function (event) {
	            _this3.onReceiveMessageCallback(targetClient, event.data);
	          };
	
	          // Store connections and channels
	          _this3.remoteConnections[targetClient] = localConnection;
	          _this3.sendChannels[targetClient] = sendChannel;
	
	          localConnection.createOffer().then(function (desc) {
	            localConnection.setLocalDescription(desc);
	            _this3.ws.send(JSON.stringify({ type: 'offer', target: targetClient, offer: desc }));
	          }).catch(_this3.onCreateSessionDescriptionError);
	        }
	      });
	    }
	  }, {
	    key: 'handleOffer',
	    value: function handleOffer(data) {
	      var _this4 = this;
	
	      var targetClient = data.from;
	
	      if (!this.remoteConnections[targetClient]) {
	        var remoteConnection = new RTCPeerConnection(null, this.pcConstraint);
	
	        remoteConnection.onicecandidate = function (e) {
	          if (e.candidate) {
	            _this4.ws.send(JSON.stringify({ type: 'candidate', target: targetClient, candidate: e.candidate }));
	          }
	        };
	        remoteConnection.ondatachannel = function (event) {
	          _this4.receiveChannelCallback(event, targetClient); // Pass targetClient to associate with the channel
	        };
	
	        remoteConnection.setRemoteDescription(new RTCSessionDescription(data.offer)).then(function () {
	          return remoteConnection.createAnswer();
	        }).then(function (desc) {
	          remoteConnection.setLocalDescription(desc);
	          _this4.ws.send(JSON.stringify({ type: 'answer', target: targetClient, answer: desc }));
	        }).catch(this.onCreateSessionDescriptionError);
	
	        // Store the remote connection
	        this.remoteConnections[targetClient] = remoteConnection;
	      }
	    }
	  }, {
	    key: 'handleAnswer',
	    value: function handleAnswer(data) {
	      var connection = this.remoteConnections[data.from];
	      connection.setRemoteDescription(new RTCSessionDescription(data.answer));
	    }
	  }, {
	    key: 'handleCandidate',
	    value: function handleCandidate(data) {
	      var connection = this.remoteConnections[data.from];
	      connection.addIceCandidate(new RTCIceCandidate(data.candidate)).catch(this.onAddIceCandidateError);
	    }
	  }, {
	    key: 'fetchDistributedClient',
	    value: function fetchDistributedClient() {
	      var sendChannelKeys = Object.keys(this.sendChannels);
	      if (sendChannelKeys.length === 0) {
	        console.warn('No send channels available.');
	        return null;
	      }
	
	      var randomIndex = Math.floor(Math.random() * sendChannelKeys.length);
	      return sendChannelKeys[randomIndex];
	    }
	  }, {
	    key: 'distributeTask',
	    value: function distributeTask(task, hamsterFood, resolve, reject) {
	      var targetClient = this.fetchDistributedClient();
	      var subTask = {
	        hamsterFood: hamsterFood,
	        index: hamsterFood.index,
	        task: task,
	        resolve: resolve,
	        reject: reject
	      };
	      this.sendData({ targetClient: targetClient, data: subTask });
	    }
	  }, {
	    key: 'sendDataResponse',
	    value: function sendDataResponse(targetClient, payload, isReply) {
	      var _this5 = this;
	
	      var sendChannel = this.receiveChannels[targetClient];
	
	      if (!sendChannel) {
	        console.error('No send or receive channel found for targetClient:', targetClient);
	        return;
	      }
	
	      payload.isReply = isReply;
	
	      if (sendChannel.readyState === 'open') {
	        sendChannel.send(JSON.stringify(payload));
	        this.trace('Sent Data to ' + targetClient + ': ' + JSON.stringify(payload));
	      } else {
	        sendChannel.onopen = function () {
	          sendChannel.send(JSON.stringify(payload));
	          _this5.trace('Sent Data to ' + targetClient + ': ' + JSON.stringify(payload));
	        };
	      }
	    }
	  }, {
	    key: 'sendData',
	    value: function sendData(data) {
	      var _this6 = this;
	
	      var targetClient = data.targetClient,
	          payload = data.data;
	
	      var sendChannel = this.sendChannels[targetClient];
	
	      // If sendChannel is not available in sendChannels, check receiveChannels
	      if (!sendChannel) {
	        sendChannel = this.receiveChannels[targetClient];
	      }
	
	      if (!sendChannel) {
	        console.error('No send or receive channel found for targetClient:', targetClient);
	        return;
	      }
	
	      if (sendChannel.readyState === 'open') {
	        sendChannel.send(JSON.stringify(payload));
	        this.trace('Sent Data to ' + targetClient + ': ' + JSON.stringify(payload));
	      } else {
	        sendChannel.onopen = function () {
	          sendChannel.send(JSON.stringify(payload));
	          _this6.trace('Sent Data to ' + targetClient + ': ' + JSON.stringify(payload));
	        };
	      }
	    }
	  }, {
	    key: 'closeDataChannels',
	    value: function closeDataChannels() {
	      for (var targetClient in this.sendChannels) {
	        this.sendChannels[targetClient].close();
	        if (this.receiveChannels[targetClient]) this.receiveChannels[targetClient].close();
	        this.remoteConnections[targetClient].close();
	      }
	      this.localConnection = null;
	      this.remoteConnections = {};
	      this.sendChannels = {};
	      this.receiveChannels = {};
	    }
	  }, {
	    key: 'receiveChannelCallback',
	    value: function receiveChannelCallback(event, targetClient) {
	      var _this7 = this;
	
	      var receiveChannel = event.channel;
	      receiveChannel.onmessage = function (event) {
	        _this7.onReceiveMessageCallback(targetClient, event.data).bind(_this7);
	      };
	      receiveChannel.onopen = this.onReceiveChannelStateChange.bind(this);
	      receiveChannel.onclose = this.onReceiveChannelStateChange.bind(this);
	
	      // Store the receive channel with targetClient ID
	      this.receiveChannels[targetClient] = receiveChannel;
	
	      // Ensure a send channel is created if it doesn't already exist
	      if (!this.sendChannels[targetClient]) {
	        var localConnection = this.remoteConnections[targetClient];
	        var sendChannel = localConnection.createDataChannel('hamstersjs', this.dataConstraint);
	
	        sendChannel.onopen = function () {
	          _this7.onSendChannelStateChange();
	        };
	        sendChannel.onclose = this.onSendChannelStateChange.bind(this);
	
	        sendChannel.onmessage = function (event) {
	          _this7.onReceiveMessageCallback(targetClient, event.data);
	        };
	
	        this.sendChannels[targetClient] = sendChannel;
	      }
	    }
	  }, {
	    key: 'onReceiveMessageCallback',
	    value: function onReceiveMessageCallback(targetClient, data) {
	      console.log('Received message!');
	      var incomingMessage = JSON.parse(data);
	
	      if (incomingMessage.isReply) {
	        console.log("K ITS READY ", incomingMessage);
	      } else {
	        // Find the targetClient associated with the receive channel
	        targetClient = this.findTargetClientByReceiveChannel(event.target);
	        if (targetClient) {
	          // Pass targetClient to runDistributedTask along with the received data
	          this.hamsters.pool.runDistributedTask(JSON.parse(event.data), targetClient);
	          // Optionally, respond using the same receive channel
	          // this.sendData({ targetClient, data: 'Response message' });
	        }
	      }
	    }
	  }, {
	    key: 'findTargetClientByReceiveChannel',
	    value: function findTargetClientByReceiveChannel(receiveChannel) {
	      for (var targetClient in this.receiveChannels) {
	        if (this.receiveChannels[targetClient] === receiveChannel) {
	          return targetClient;
	        }
	      }
	      return null;
	    }
	  }, {
	    key: 'onSendChannelStateChange',
	    value: function onSendChannelStateChange() {
	      // Handle send channel state change if needed
	    }
	  }, {
	    key: 'onReceiveChannelStateChange',
	    value: function onReceiveChannelStateChange() {
	      // Handle receive channel state change if needed
	    }
	  }, {
	    key: 'trace',
	    value: function trace(arg) {
	      var now = (window.performance.now() / 1000).toFixed(3);
	      console.log(now + ': ', arg);
	    }
	  }, {
	    key: 'onCreateSessionDescriptionError',
	    value: function onCreateSessionDescriptionError(error) {
	      this.trace('Failed to create session description: ' + error.toString());
	    }
	  }, {
	    key: 'onAddIceCandidateError',
	    value: function onAddIceCandidateError(error) {
	      this.trace('Failed to add Ice Candidate: ' + error.toString());
	    }
	  }]);
	
	  return Distribute;
	}();
	
	module.exports = Distribute;

/***/ })
/******/ ]);
//# sourceMappingURL=hamsters.node.min.js.map