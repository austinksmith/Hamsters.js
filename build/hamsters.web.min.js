!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.hamsters=t():e.hamsters=t()}(this,(()=>(()=>{"use strict";var __webpack_modules__={327:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{A:()=>__WEBPACK_DEFAULT_EXPORT__});class Legacy{constructor(hamsters){this.hamsters=hamsters,this.scaffold=(params,resolve,reject)=>{var rtn={data:[],dataType:void 0!==params.dataType?params.dataType:null};this.hamsters.habitat.reactNative&&(self.rtn=rtn),this.hamsters.habitat.node||this.hamsters.habitat.isIE?eval(params.hamstersJob):params.hamstersJob(),resolve(rtn.data)}}}const __WEBPACK_DEFAULT_EXPORT__=Legacy},386:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{A:()=>__WEBPACK_DEFAULT_EXPORT__});class Regular{constructor(){this.scaffold=function(){function handleDataType(e){return this.params.sharedArray||this.params.dataType&&(e.data=typedArrayFromBuffer(e.dataType,e.data)),getTransferableObjects(e)}function typedArrayFromBuffer(e,t){const s={Uint32:Uint32Array,Uint16:Uint16Array,Uint8:Uint8Array,Uint8clamped:Uint8ClampedArray,Int32:Int32Array,Int16:Int16Array,Int8:Int8Array,Float32:Float32Array,Float64:Float64Array};return s[e]?new s[e](t):t}function returnResponse(e,t){t&&t.length>0?postMessage(e,t):postMessage(e)}function getTransferableObjects(e){const t=new Set,s=["Int32Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Uint32Array","Float32Array","Float64Array"],r="undefined"!=typeof self?self:window,a=[...s,"ArrayBuffer","MessagePort","ImageBitmap","OffscreenCanvas"];for(const n in e)if(e.hasOwnProperty(n))for(const i of a)void 0!==r[i]&&e[n]instanceof r[i]&&(s.includes(i)?t.add(e[n].buffer):t.add(e[n]));return Array.from(t)}self.params={},self.rtn={},self.onmessage=function(message){this.params=message.data,this.rtn={data:[],dataType:void 0!==this.params.dataType?this.params.dataType:null,index:this.params.index},this.params.sharedBuffer&&(this.params.sharedArray=typedArrayFromBuffer(this.params.dataType,this.params.sharedBuffer)),eval(this.params.hamstersJob);const buffers=handleDataType(this.rtn);returnResponse(this.rtn,buffers)}.bind(this)}}}const __WEBPACK_DEFAULT_EXPORT__=Regular},817:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{A:()=>__WEBPACK_DEFAULT_EXPORT__});class Shared{constructor(){this.scaffold=function(){self.params={},self.rtn={},addEventListener("connect",(incomingConnection=>{var port=incomingConnection.ports[0];port.start(),port.addEventListener("message",(incomingMessage=>{this.params=incomingMessage.data,this.rtn={data:[],dataType:this.params.dataType},eval("("+this.params.hamstersJob+")")(),port.postMessage(this.rtn)}),!1)}),!1)}}}const __WEBPACK_DEFAULT_EXPORT__=Shared}},__webpack_module_cache__={};function __webpack_require__(e){var t=__webpack_module_cache__[e];if(void 0!==t)return t.exports;var s=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](s,s.exports,__webpack_require__),s.exports}__webpack_require__.d=(e,t)=>{for(var s in t)__webpack_require__.o(t,s)&&!__webpack_require__.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:t[s]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__webpack_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);var __webpack_exports__={};__webpack_require__.d(__webpack_exports__,{default:()=>hamsters_0});class Habitat{constructor(e){this.hamsters=e,this.debug=!1,this.importScripts=null,this.relay=null,this.memoize=!1,this.persistence=!0,this.browser=this.isBrowser(),this.webWorker=this.isWebWorker(),this.node=this.isNode(),this.reactNative=this.isReactNative(),this.shell=this.isShell(),this.transferable=this.supportsTransferableObjects(),this.atomics=this.supportsAtomicOperations(),this.proxies=this.supportsProxies(),this.isIE=this.isInternetExplorer(),this.selectHamsterWheel=this.selectHamsterWheel.bind(this),this.sharedWorker=this.locateSharedWorkerObject(),this.locateBlobBuilder=this.findAvailableBlobBuilder(),this.legacy=this.isLegacyEnvironment(),this.Worker=this.locateWorkerObject(),this.maxThreads=this.determineGlobalThreads(),this.keys=this.getHabitatKeys()}determineGlobalThreads(){let e=4;return this.browser&&void 0!==navigator.hardwareConcurrency&&(e=navigator.hardwareConcurrency,this.isFirefox()&&(e=e>20?20:e)),this.node&&"undefined"!=typeof os&&(e=os.cpus().length),e}isFirefox(){return"undefined"!=typeof navigator&&void 0!==navigator.userAgent&&-1!==navigator.userAgent.toLowerCase().indexOf("firefox")}locateWorkerObject(){return"undefined"!=typeof Worker&&Worker}locateSharedWorkerObject(){return"undefined"!=typeof SharedWorker&&SharedWorker}isBrowser(){return"object"==typeof window}isInternetExplorer(){return"undefined"!=typeof navigator&&void 0!==navigator.userAgent&&(-1!==navigator.userAgent.indexOf("MSIE ")||-1!==navigator.userAgent.indexOf("Trident/"))}isNode(){return"object"==typeof process&&!this.isWebWorker()&&!this.browser}isWebWorker(){return"function"==typeof importScripts&&!this.isReactNative()}isReactNative(){return"undefined"!=typeof navigator&&void 0!==navigator.product&&"ReactNative"===navigator.product}isShell(){return"undefined"==typeof navigator&&!this.isNode()&&!this.isWebWorker()&&!this.isReactNative()}isLegacyEnvironment(){let e=!this.Worker;return this.isWebWorker()&&void 0!==this.SharedWorker&&(e=!this.supportsSharedWorkers()),e}supportsSharedWorkers(){return"undefined"!=typeof SharedWorker}findAvailableBlobBuilder(){return"undefined"!=typeof BlobBuilder?BlobBuilder:"undefined"!=typeof WebKitBlobBuilder?WebKitBlobBuilder:"undefined"!=typeof MozBlobBuilder?MozBlobBuilder:"undefined"!=typeof MSBlobBuilder?MSBlobBuilder:"Environment does not support data blobs!"}createDataBlob(e){if("undefined"==typeof Blob){let t=new(this.locateBlobBuilder());return t.append([e],{type:"application/javascript"}),t.getBlob()}return new Blob([e],{type:"application/javascript"})}generateWorkerBlob(e){return URL.createObjectURL(this.createDataBlob(this.generateWorkerString(e)))}generateWorkerString(e){return`(${e.toString()})();`}supportsTransferableObjects(){return"undefined"!=typeof Uint8Array}supportsAtomicOperations(){return"undefined"!=typeof SharedArrayBuffer}supportsProxies(){return"undefined"!=typeof Proxy}selectHamsterWheel(){return this.hamsters.scaffold.custom?this.hamsters.scaffold.custom:this.isIE?this.hamsters.scaffold.legacy.scaffold:this.reactNative?"reactNativeHamster.js":this.node?"./node_modules/hamsters.js/build/common/node.js":"data:text/javascript,"+encodeURIComponent(this.generateWorkerString(this.hamsters.scaffold.regular.scaffold))}getHabitatKeys(){return["worker","sharedworker","legacy","proxies","reactnative","atomics","transferable","browser","shell","node","debug","persistence","importscripts","maxthreads","parentport","webworker","relay"]}}const habitat=Habitat;class Pool{constructor(e){this.hamsters=e,this.threads=new e.observable([]),this.running=new e.observable([]),this.pending=new e.observable([]),this.fetchHamster=this.getAvailableThread.bind(this)}addWorkToPending(e,t,s,r,a){this.hamsters.habitat.debug&&(s.scheduler.metrics.threads[s.scheduler.count].enqueued_at=Date.now()),this.pending.push({index:e,hamsterFood:t,task:s,resolve:r,reject:a})}processQueuedItem(e,t){return this.hamsters.habitat.debug&&(t.task.scheduler.metrics.threads[t.index.id].dequeued_at=Date.now()),this.runTask(e,t.index,t.hamsterFood,t.task,t.resolve,t.reject)}getAvailableThread(e){return this.hamsters.habitat.persistence?this.threads.get(e):this.spawnHamster()}keepTrackOfThread(e,t){this.hamsters.habitat.debug&&(e.scheduler.metrics.threads[t].started_at=Date.now()),e.scheduler.workers.push(t),this.running.push(t)}spawnHamsters(e){for(;e--;)this.threads.push(this.spawnHamster())}spawnHamster(){const{selectHamsterWheel:e,Worker:t}=this.hamsters.habitat;return new t(e())}prepareMeal(e,t,s){e.id=t;const r={array:s.input.array&&0!==s.input.array.length?this.hamsters.data.getSubArrayFromIndex(e,s.input.array):[],index:e};void 0!==s.scheduler.sharedBuffer&&(r.sharedBuffer=s.scheduler.sharedBuffer);const a=new Set(["array","threads","sharedArray"]);for(const e in s.input)s.input.hasOwnProperty(e)&&!a.has(e)&&(r[e]=s.input[e]);return r}runDistributedTask(e,t){const s=this.fetchHamster(this.running.length());let r=e.task,a=e.hamsterFood.index,n=this.hamsters.distribute.returnDistributedOutput;r.targetClient=t,r.messageId=e.messageId,r.type="task-response",this.runTask(s,a,e.hamsterFood,e.task,n,n)}runTask(e,t,s,r,a,n){const i=this.running.length();this.hamsters.pool.keepTrackOfThread(r,i),this.hamsters.habitat.legacy?this.hamsters.scaffold.legacy.scaffold(s,a,n):(this.hamsters.trainer?this.hamsters.trainer(t,r,i,e,a,n):this.hamsters.pool.trainHamster(t,r,i,e,a,n),this.hamsters.data.feedHamster(e,s)),r.scheduler.count+=1}hamsterWheel(e,t,s,r,a){const n=this.prepareMeal(e,t,s);if(this.hamsters.habitat.maxThreads<=this.running.length())this.addWorkToPending(e,n,s,r,a);else if(s.input.distribute)this.hamsters.distribute.distributeTask(s,n,r,a);else{const t=this.fetchHamster(this.running.length());this.runTask(t,e,n,s,r,a)}}processDistributedReturn(e){}returnOutputAndRemoveTask(e,t){e.scheduler.sharedBuffer&&(e.output=hamsters.data.processDataType(e.input.dataType,e.scheduler.sharedBuffer)),e.input.aggregate&&(e.output=this.hamsters.data.aggregateThreadOutputs(e.output,e.input.dataType)),e.input.sort&&(e.output=this.hamsters.data.sortOutput(e.output,e.input.sort)),this.hamsters.habitat.debug&&(e.scheduler.metrics.completed_at=Date.now(),console.info("Hamsters.js Task Completed: ",e)),e.input.distribute?t(e):t(e.output)}removeFromRunning(e,t){this.running.splice(this.running.indexOf(t),1),e.scheduler.workers.splice(e.scheduler.workers.indexOf(t),1)}processReturn(e,t,s){const r=this.hamsters.habitat.reactNative,a=this.hamsters.habitat.node,n=t.data,i=r?JSON.parse(t).data:void 0!==n.data?n.data:n,o=a?t.index.id:n.index.id;1!==s.scheduler.threads?r||s.input.mixedOutput?s.output[o]=i:this.hamsters.data.addThreadOutputWithIndex(s,e,i):s.output=i}setOnMessage(e,t,s){this.hamsters.habitat.node?(e.on("message",t),e.on("onmessageerror",s),e.on("error",s)):(e.onmessage=t,e.onmessageerror=s,e.onerror=s)}trainHamster(e,t,s,r,a,n){this.hamsters.pool.setOnMessage(r,(n=>{if(this.hamsters.pool.processReturn(e,n,t),this.hamsters.habitat.debug&&(t.scheduler.metrics.threads[s].completed_at=Date.now()),this.hamsters.pool.removeFromRunning(t,s),0===t.scheduler.workers.length&&t.scheduler.count===t.scheduler.threads&&this.hamsters.pool.returnOutputAndRemoveTask(t,a),this.hamsters.habitat.persistence||r.terminate(),0!==this.hamsters.pool.pending.length()){const e=this.hamsters.pool.fetchHamster(this.hamsters.pool.running.length());this.hamsters.pool.processQueuedItem(e,this.hamsters.pool.pending.shift())}}),n)}scheduleTask(e){let t=0;return new Promise(((s,r)=>{for(this.hamsters.debug&&(e.scheduler.metrics.started_at=Date.now());t<e.scheduler.threads;)this.hamsterWheel(e.scheduler.indexes[t],t,e,s,r),t+=1}))}}const pool=Pool;class Data{constructor(e){this.hamsters=e,this.getSubArrayFromIndex=this.getSubArrayUsingIndex.bind(this),this.getSubArrayIndexes=this.calculateIndexes.bind(this),this.sortOutput=this.sortTaskOutput.bind(this),this.aggregateThreadOutputs=this.aggregateThreadOutputs.bind(this),this.processDataType=this.typedArrayFromBuffer,this.prepareFunction=this.prepareWorkerTask.bind(this),this.feedHamster=this.messageWorkerThread.bind(this),this.getBufferSize=this.getBufferSize,this.createSharedBuffer=this.createSharedBuffer.bind(this),this.getDataType=this.getDataType,this.setupSharedArrayBuffer=this.setupSharedArrayBuffer.bind(this)}messageWorkerThread(e,t){return this.hamsters.habitat.reactNative?e.postMessage(JSON.stringify(t)):e.postMessage(t,this.hamsters.data.getTransferableObjects(t))}getTransferableObjects(e){const t=[],s=[],r=["Int32Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Uint32Array","Float32Array","Float64Array"],a=["ArrayBuffer","MessagePort","ImageBitmap","OffscreenCanvas"],n="undefined"!=typeof window?window:__webpack_require__.g;for(const i in e){for(const s of r)if(void 0!==n[s]&&e[i]instanceof n[s]){t.push(e[i].buffer);break}for(const t of a)if(void 0!==n[t]&&e[i]instanceof n[t]){s.push(e[i]);break}}return t.concat(s)}typedArrayFromBuffer(e,t){const s={Uint32:Uint32Array,Uint16:Uint16Array,Uint8:Uint8Array,Uint8clamped:Uint8ClampedArray,Int32:Int32Array,Int16:Int16Array,Int8:Int8Array,Float32:Float32Array,Float64:Float64Array};return s[e]?new s[e](t):t}prepareWorkerTask(e){let t=String(e),s=t.trim().startsWith("async");return e=t.substring(t.indexOf("{")+1,t.lastIndexOf("}")),s?`(async () => {\n        ${e}\n      })();`:e}sortTaskOutput(e,t){switch(t){case"desc":case"asc":return Array.prototype.sort.call(e,(function(e,s){return"asc"===t?e-s:s-e}));case"ascAlpha":return e.sort();case"descAlpha":return e.reverse();default:return e}}getBufferSize(e){return e.byteLength}createSharedBuffer(e){const t=this.getBufferSize(e),s=new SharedArrayBuffer(t);return new e.constructor(s).set(e),s}setupSharedArrayBuffer(e){return this.createSharedBuffer(e)}aggregateThreadOutputs(e,t){if(!t)return e.reduce((function(e,t){return e.concat(t)}));let s=0,r=e.length,a=0;for(;s<r;s+=1)a+=e[s].length;let n=this.processDataType(t,a),i=0;for(s=0;s<r;s+=1)n.set(e[s],i),i+=e[s].length;return n}addThreadOutputWithIndex(e,t,s){let r=0;const a=s.length;for(;r<a;r++)e.output[t.start+r]=s[r]}calculateIndexes(e,t){if(1===t)return[{start:0,end:e.length-1}];const s=[],r=Math.floor(e.length/t);let a=0;for(let e=0;e<t;e++){const e=a+r-1;s.push({start:a,end:e}),a=e+1}return a<e.length&&(s[t-1].end=e.length-1),s}prepareDistributedTask(e){return Object.keys(e.input).forEach((t=>{Array.isArray(e.input[t])&&(e.input[t]=null)})),e}getTransferList(e,t){const s={};return t=this.prepareDistributedTask(t),Object.keys(e).forEach((t=>{Array.isArray(e[t])&&(s[t]=e[t],e[t]="Awaiting Transfer")})),{hamsterFood:e,transferList:s,task:t,transferCount:Object.keys(s).length}}getSubArrayUsingIndex(e,t){return t.slice(e.start,e.end+1)}}const data=Data;class Task{constructor(e,t,s){this.input=t,this.output=[],this.scheduler={count:0,threads:t.threads||1,transfers:{request:0,send:0},workers:[]},e.habitat.legacy?this.setupLegacyTask(e,s):this.setupModernTask(e,t,s),e.habitat.debug&&this.setupDebugMetrics()}setupLegacyTask(e,t){this.scheduler.threads=1,e.habitat.node||e.habitat.isIE||(this.input.hamstersJob=t)}setupModernTask(e,t,s){this.input.hamstersJob=e.habitat.legacy?s:e.data.prepareFunction(s),t.sharedArray&&e.habitat.atomics?(this.scheduler.indexes=t.indexes||e.data.getSubArrayIndexes(t.sharedArray,this.scheduler.threads),this.scheduler.sharedBuffer=e.data.setupSharedArrayBuffer(t.sharedArray),this.input.sharedArray=[]):this.scheduler.indexes=t.indexes||e.data.getSubArrayIndexes(t.array,this.scheduler.threads)}setupDebugMetrics(){this.scheduler.metrics={created_at:Date.now(),started_at:null,completed_at:null,threads:this.setupThreadMetrics()}}setupThreadMetrics(){let e=0,t=[];for(;e<this.scheduler.threads;)t.push({created_at:Date.now(),started_at:null,enqueued_at:null,dequeued_at:null,completed_at:null}),e+=1;return t}}const task=Task;var legacy=__webpack_require__(327),regular=__webpack_require__(386),shared=__webpack_require__(817);class NodeStore{constructor(e){this.maxSize=e,this.cache=new Map}get(e){if(this.cache.has(e)){const t=this.cache.get(e);return this.cache.delete(e),this.cache.set(e,t),Promise.resolve(t)}return Promise.resolve(null)}set(e,t){if(this.cache.size>=this.maxSize){const e=this.cache.keys().next().value;this.cache.delete(e)}return this.cache.set(e,t),Promise.resolve()}clear(){return this.cache.clear(),Promise.resolve()}}const stores_NodeStore=NodeStore;class WebStore{constructor(e,t,s){this.dbName=e,this.storeName=t,this.maxSize=s,this.db=null,this.initDB()}initDB(){const e=this,t=indexedDB.open(this.dbName,1);t.onerror=function(e){console.error("Error opening database:",e.target.error)},t.onupgradeneeded=function(t){const s=t.target.result;if(!s.objectStoreNames.contains(e.storeName)){const t=s.createObjectStore(e.storeName,{keyPath:"key"});t.createIndex("by_key","key",{unique:!0}),t.createIndex("by_timestamp","timestamp")}},t.onsuccess=function(t){e.db=t.target.result}}get(e){const t=this;return new Promise((function(s,r){if(!t.db)return console.error("Database not initialized"),void s(null);const a=t.db.transaction([t.storeName],"readonly").objectStore(t.storeName).get(e);a.onsuccess=function(a){const n=a.target.result;n?t.updateTimestamp(e).then((()=>s(n.value))).catch(r):s(null)},a.onerror=function(e){r(e.target.error)}}))}set(e,t){const s=this;return new Promise((function(r,a){if(!s.db)return console.error("Database not initialized"),void r();s.checkSize().then((()=>{const n=s.db.transaction([s.storeName],"readwrite").objectStore(s.storeName).put({key:e,value:t,timestamp:Date.now()});n.onsuccess=function(){r()},n.onerror=function(e){a(e.target.error)}})).catch(a)}))}clear(){const e=this;return new Promise((function(t,s){if(!e.db)return console.error("Database not initialized"),void t();const r=e.db.transaction([e.storeName],"readwrite").objectStore(e.storeName).clear();r.onsuccess=function(){t()},r.onerror=function(e){s(e.target.error)}}))}checkSize(){const e=this;return new Promise((function(t,s){const r=e.db.transaction([e.storeName],"readonly").objectStore(e.storeName).count();r.onsuccess=function(){r.result>=e.maxSize?e.evictOldest().then(t).catch(s):t()},r.onerror=function(e){s(e.target.error)}}))}evictOldest(){const e=this;return new Promise((function(t,s){const r=e.db.transaction([e.storeName],"readwrite").objectStore(e.storeName).index("by_timestamp").openCursor(null,"next");r.onsuccess=function(e){const s=e.target.result;s?s.delete().onsuccess=function(){t()}:t()},r.onerror=function(e){s(e.target.error)}}))}updateTimestamp(e){const t=this;return new Promise((function(s,r){const a=t.db.transaction([t.storeName],"readwrite").objectStore(t.storeName),n=a.get(e);n.onsuccess=function(e){const t=e.target.result;t?(t.timestamp=Date.now(),a.put(t).onsuccess=function(){s()}):s()},n.onerror=function(e){r(e.target.error)}}))}}const stores_WebStore=WebStore;class Memoize{constructor(e,t){this.hamsters=e,this.store=this.hamsters.habitat.node?new stores_NodeStore(t):new stores_WebStore("hamstersjs","cacheStore",t)}memoize(e){const t=this;return function(s){const r=t.generateTaskKey(s);return new Promise((function(a,n){t.store.get(r).then((function(i){null!==i?a(i):t.applyFunc(e,s).then((function(e){t.store.set(r,e).then((function(){a(e)})).catch(n)})).catch(n)})).catch(n)}))}}generateTaskKey(e){const t=JSON.stringify({input:e.input});return this.hashCode(t)}hashCode(e){let t,s,r=0;if(0===e.length)return r;for(t=0;t<e.length;t++)s=e.charCodeAt(t),r=(r<<5)-r+s,r|=0;return r.toString()}applyFunc(e,t){return new Promise(((s,r)=>{try{s(e.apply(null,t))}catch(e){r(e)}}))}}const memoize=Memoize;class Distribute{constructor(e){this.hamsters=e,this.localConnection=null,this.remoteConnections=new e.observable({}),this.clientInfo=new e.observable({}),this.sendChannels=new e.observable({}),this.receiveChannels=new e.observable({}),this.pcConstraint=null,this.dataConstraint=null,this.ws=null,this.clientId=null,this.pendingPromises=new e.observable({}),this.pendingTasks=new e.observable({}),this.pendingTransfers=new e.observable({}),this.awaitingTransfers=new e.observable({}),this.lastRequestedTransfers=new e.observable({}),this.pendingOutputs=new e.observable({}),this.returnDistributedOutput=this.sendDataResponse.bind(this),this.establishConnection=this.initWebSocket.bind(this),this.lastHeartbeat={},this.heartBeatInterval=3e4,this.heartBeatTimeout={},this.startPeriodicLatencyChecks()}initWebSocket(){this.ws=new WebSocket(`${this.hamsters.habitat.relay}`),this.ws.onopen=()=>{console.info(`Hamsters.js ${this.hamsters.version} connection established`),this.ws.send(JSON.stringify({type:"register",logicalCores:this.hamsters.maxThreads})),this.sendHeartBeat(this.heartBeatInterval)},this.ws.onmessage=e=>{const t=JSON.parse(e.data);this.handleWebSocketMessage(t)},this.ws.onerror=e=>{this.hamsters.habitat.debug&&console.error(`Hamsters.js ${this.hamsters.version} connection error:`,e)},this.ws.onclose=()=>{this.hamsters.habitat.debug&&console.info(`Hamsters.js ${this.hamsters.version} connection closed. Reconnecting...`),this.establishConnection()}}handleWebSocketMessage(e){const t={register:this.handleClientReconnect.bind(this),"update-client-list":this.updateClientList.bind(this),offer:this.handleOffer.bind(this),answer:this.handleAnswer.bind(this),candidate:this.handleCandidate.bind(this)}[e.type];t?t(e):this.hamsters.habitat.debug&&console.info(`Hamsters.js ${this.hamsters.version} unknown message type: ${e.type}`)}sendHeartBeat(e){this.heartBeatTimeout=setInterval((()=>{this.ws.send(JSON.stringify({type:"heartbeat"})),this.lastHeartbeat=Date.now()}),e)}startPeriodicLatencyChecks(){setInterval((()=>{const e=this.sendChannels.getData();Object.keys(e).forEach((e=>{this.measureLatency(e)}))}),arguments.length>0&&void 0!==arguments[0]?arguments[0]:3e4)}updateClientList(e){const t=e.clients,s=new Set(t.map((e=>e.id)));t.forEach((e=>{e.id===this.clientId||this.remoteConnections.get(e.id)||this.createConnection(e.id)}));const r=this.remoteConnections.getData();Object.keys(r).forEach((e=>{s.has(e)||this.handleClientDisconnect(e)}))}handleClientDisconnect(e){this.remoteConnections.get(e)&&(this.remoteConnections.get(e).close(),this.remoteConnections.delete(e)),this.sendChannels.get(e)&&(this.sendChannels.get(e).close(),this.sendChannels.delete(e)),this.receiveChannels.get(e)&&(this.receiveChannels.get(e).close(),this.receiveChannels.delete(e)),this.clientInfo.delete(e)}handleClientReconnect(e){const t=e.id;this.clientId!==t?(this.handleClientDisconnect(t),this.clientId=t):this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} reconnected with same ID`)}createConnection(e){if(e===this.clientId||this.remoteConnections.get(e))return;const t=new RTCPeerConnection({iceServers:[{urls:"stun:stun.l.google.com:19302"}]},this.pcConstraint),s=t.createDataChannel("hamstersjs",this.dataConstraint);t.onicecandidate=t=>{t.candidate&&this.ws.send(JSON.stringify({type:"candidate",target:e,from:this.clientId,logicalCores:this.hamsters.maxThreads,userAgent:navigator.userAgent,candidate:t.candidate}))},s.onopen=()=>{this.onSendChannelStateChange(e)},s.onclose=()=>{this.onSendChannelStateChange(e)},s.onmessage=t=>{this.onReceiveMessageCallback(e,t.data)},t.ondatachannel=t=>{this.receiveChannelCallback(t,e)},this.remoteConnections.set(e,t),this.sendChannels.set(e,s),this.receiveChannels.set(e,null),t.createOffer().then((s=>{t.setLocalDescription(s),this.ws.send(JSON.stringify({type:"offer",target:e,offer:s}))})).catch(this.onCreateSessionDescriptionError.bind(this))}handleOffer(e){const t=e.from;if(!this.remoteConnections.get(t)){const s=new RTCPeerConnection({iceServers:[{urls:"stun:stun.l.google.com:19302"}]},this.pcConstraint);s.onicecandidate=e=>{e.candidate&&this.ws.send(JSON.stringify({type:"candidate",target:t,logicalCores:this.hamsters.maxThreads,userAgent:navigator.userAgent,candidate:e.candidate}))},s.ondatachannel=e=>{this.receiveChannelCallback(e,t)};const r=s.createDataChannel("hamstersjs",this.dataConstraint);r.onopen=()=>{this.onSendChannelStateChange(t)},r.onclose=()=>{this.onSendChannelStateChange(t)},r.onmessage=e=>{this.onReceiveMessageCallback(t,e.data)},s.setRemoteDescription(new RTCSessionDescription(e.offer)).then((()=>s.createAnswer())).then((e=>{s.setLocalDescription(e),this.ws.send(JSON.stringify({type:"answer",target:t,logicalCores:this.hamsters.maxThreads,userAgent:navigator.userAgent,answer:e}))})).catch(this.onCreateSessionDescriptionError.bind(this)),this.remoteConnections.set(t,s),this.sendChannels.set(t,r)}}storeClientConnectionInfo(e){const t={logicalCores:e.logicalCores,userAgent:e.userAgent};this.clientInfo.set(e.from,t)}handleAnswer(e){this.storeClientConnectionInfo(e),this.remoteConnections.get(e.from).setRemoteDescription(new RTCSessionDescription(e.answer))}handleCandidate(e){let t=this.remoteConnections.get(e.from);t||(this.storeClientConnectionInfo(e),t=this.remoteConnections.get(e.from)),t.addIceCandidate(new RTCIceCandidate(e.candidate)).catch(this.onAddIceCandidateError.bind(this))}distributeTask(e,t,s,r){const a=this.getDistributedClient();if(!a)return this.hamsters.habitat.debug&&console.error(`Hamsters.js ${this.hamsters.version} no target client found.`),void r("No target client found.");const n=this.generateUniqueId(),i=this.hamsters.data.getTransferList(t,e),o={hamsterFood:i.hamsterFood,index:t.index,task:i.task,messageId:n,type:"task-request"};this.pendingPromises.set(n,{resolve:s,reject:r}),i.transferCount>0&&this.pendingTransfers.set(n,i.transferList),this.sendData({targetClient:a,data:o})}getDistributedClient(){const e=Object.keys(this.sendChannels.getData());if(0===e.length)return this.hamsters.habitat.debug&&console.warn(`Hamsters.js ${this.hamsters.version} no send channels available.`),null;let t=1/0,s=null;return e.forEach((e=>{const r=this.sendChannels.get(e),a=this.clientInfo.get(e);"open"===r.readyState&&a&&a.latency<t&&(t=a.latency,s=e)})),s}initializeDistributedTask(e,t,s){const r={};Object.keys(t.hamsterFood).forEach((e=>{"Awaiting Transfer"===t.hamsterFood[e]&&(r[e]="Awaiting Transfer")})),Object.keys(r).length>0?(this.awaitingTransfers.set(e,{transfers:r,messageId:s}),this.requestNextTransfer(e,s)):this.runDistributedTask(t,e)}requestNextTransfer(e,t){if(this.lastRequestedTransfers.get(e))return;const s=this.awaitingTransfers.get(e);if(!s)return;const{transfers:r,messageId:a}=s,n=Object.keys(r);if(n.length>0&&t===a){const s=n.find((e=>"Awaiting Transfer"===r[e]));s&&this.requestDataTransfer(s,t,e)}}requestDataTransfer(e,t,s){const r={type:"transfer-request",key:e,messageId:t};this.lastRequestedTransfers.set(s,{key:e,messageId:t}),this.sendData({targetClient:s,data:r});const a=this.awaitingTransfers.get(s)||{transfers:{}};a.transfers[e]="Requested Transfer",this.awaitingTransfers.set(s,a),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} requested transfer for ${e} from ${s}`)}handleTransferResponse(e,t){const s=this.lastRequestedTransfers.get(e);if(!s)return void console.error(`Hamsters.js ${this.hamsters.version} received transfer response but no transfer was requested for ${e}`);const r=s.key,a=s.messageId||null,n=s.responseId||null,i=this.pendingTasks.get(e),o=this.awaitingTransfers.get(e),h=o&&"Requested Transfer"===o.transfers[r];i&&h?(i.hamsterFood[r]=this.convertFromArrayBuffer(t,r),delete o.transfers[r],0===Object.keys(o.transfers).length?(this.awaitingTransfers.delete(e),this.pendingTasks.delete(e),this.lastRequestedTransfers.delete(e),this.runDistributedTask(i,e)):(this.awaitingTransfers.set(e,o),this.lastRequestedTransfers.delete(e),this.requestNextTransfer(e)),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} processed transfer response for ${r} from ${e}`)):"output"===r?this.handleTaskResponse(e,{output:this.convertFromArrayBuffer(t),messageId:a,responseId:n}):console.error(`Hamsters.js ${this.hamsters.version} received unexpected transfer response for ${e}`)}measureLatency(e){const t=performance.now();this.sendPing(e,t)}sendPing(e,t){const s=this.sendChannels.get(e);s&&"open"===s.readyState&&s.send(JSON.stringify({type:"ping",startTime:t}))}handlePing(e,t){const s=this.sendChannels.get(e);s&&"open"===s.readyState&&(s.send(JSON.stringify({type:"pong",startTime:t})),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} sent pong to ${e}`))}handlePong(e,t){const s=performance.now()-t,r=this.clientInfo.get(e)||{};r.latency=s,this.clientInfo.set(e,r),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} received pong from ${e} with latency: ${s.toFixed(2)}ms`)}runDistributedTask(e,t){this.hamsters.pool.runDistributedTask(e,t)}sendDataResponse(e){const{targetClient:t,messageId:s,output:r}=e;this.initializeOutputTransfer(t,r,s)}initializeOutputTransfer(e,t,s){const r=this.generateUniqueId();this.pendingOutputs.set(r,{targetClient:e,output:t,messageId:s});const a={type:"task-response",messageId:s,responseId:r,awaitingTransfers:!0};this.sendData({targetClient:e,data:a}),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} initialized output transfer for ${e} (responseId: ${r})`)}handleOutputTransferRequest(e,t){const{responseId:s}=t,r=this.pendingOutputs.get(s);if(r&&r.targetClient===e){const t=this.getArrayBuffer(r.output);this.sendBlobData({targetClient:e,data:t,dataType:"arrayBuffer"}),this.pendingOutputs.delete(s),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} sent output transfer for ${e} (responseId: ${s})`)}else console.error(`Hamsters.js ${this.hamsters.version} received unexpected output transfer request for ${e}`)}getArrayBuffer(e){return ArrayBuffer.isView(e)?e.buffer:e instanceof ArrayBuffer?e:new Uint8Array(e).buffer}convertFromArrayBuffer(e,t){return new Uint8Array(e)}sendData(e){let{targetClient:t,data:s}=e;const r=this.sendChannels.get(t);r&&"open"===r.readyState?(r.send(JSON.stringify(s)),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} sent data to: ${t}`)):this.hamsters.habitat.debug&&console.error(`Hamsters.js ${this.hamsters.version} send channel is not open for targetClient: ${t}`)}sendBlobData(e){let{targetClient:t,data:s,dataType:r}=e;const a=this.sendChannels.get(t);a&&"open"===a.readyState?(a.send(s),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} sent blob data to: ${t}`)):this.hamsters.habitat.debug&&console.error(`Hamsters.js ${this.hamsters.version} send channel is not open for targetClient: ${t}`)}onReceiveMessageCallback(e,t){if(t instanceof ArrayBuffer)this.handleTransferResponse(e,t);else if("string"==typeof t){let s;try{s=JSON.parse(t),this.handleIncomingMessage(e,s)}catch(e){console.error(`Hamsters.js ${this.hamsters.version} error parsing message:`,e)}}else console.log("Received unexpected data type:",typeof t)}handleIncomingMessage(e,t){const s={"transfer-request":this.fulfillTransferRequest.bind(this),"task-request":this.handleTaskRequest.bind(this),"transfer-response":this.processTransferResponse.bind(this),"output-transfer-request":this.handleOutputTransferRequest.bind(this),"task-response":this.handleTaskResponse.bind(this),ping:(e,t)=>this.handlePing(e,t.startTime),pong:(e,t)=>this.handlePong(e,t.startTime)}[t.type];s?s(e,t):console.log(`Hamsters.js ${this.hamsters.version} unknown message received from: ${e}`)}handleTaskRequest(e,t){Object.values(t.hamsterFood).some((e=>"Awaiting Transfer"===e))?(this.pendingTasks.set(e,t),this.initializeDistributedTask(e,t,t.messageId)):this.runDistributedTask(t,e)}handleTaskResponse(e,t){const{messageId:s,responseId:r,awaitingTransfers:a}=t;if(a)this.requestOutputTransfer(e,r,s);else{const e=this.pendingPromises.get(s);e&&(e.resolve(t.output),this.pendingPromises.delete(s))}}requestOutputTransfer(e,t,s){const r={type:"output-transfer-request",key:"output",responseId:t,messageId:s};this.lastRequestedTransfers.set(e,r),this.sendData({targetClient:e,data:r})}requestDataTransfer(e,t,s){const r={type:"transfer-request",key:e,messageId:t};this.lastRequestedTransfers.set(s,{key:e,messageId:t}),this.sendData({targetClient:s,data:r});const a=this.awaitingTransfers.get(s);a&&a.messageId===t&&(a.transfers[e]="Requested Transfer",this.awaitingTransfers.set(s,a)),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} requested transfer for ${e} from ${s} (messageId: ${t})`)}fulfillTransferRequest(e,t){const{key:s,messageId:r,responseId:a}=t,n=a||r,i=this.pendingTransfers.get(n);if(i&&i[s]){const t=i[s],o=this.getArrayBuffer(t);this.sendBlobData({targetClient:e,data:o,dataType:"arrayBuffer"}),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} sent transfer response for ${s} (${a?"output":"input"}) to ${e} (messageId: ${r})`),delete i[s],0===Object.keys(i).length&&this.pendingTransfers.delete(n)}else console.error(`No pending transfer found for ${s} (${a?"output":"input"}) for ${e} (messageId: ${r})`)}processTransferResponse(e,t){const{key:s,data:r,messageId:a,responseId:n}=t;if(n){const e=this.pendingPromises.get(a);e?(e.resolve(r),this.pendingPromises.delete(a)):console.warn(`Hamsters.js ${this.hamsters.version} no pending promise found for messageId: ${a}`)}else{const t=this.pendingTasks.get(e);t&&t.messageId===a?(t.hamsterFood[s]=r,Object.values(t.hamsterFood).some((e=>"Awaiting Transfer"===e))||(this.pendingTasks.delete(e),this.hamsters.pool.runDistributedTask(t,e))):console.warn(`Hamsters.js ${this.hamsters.version} no pending task found for targetClient: ${e} and messageId: ${a}`)}this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} processed transfer response for ${s} from ${e}`)}receiveChannelCallback(e,t){const s=e.channel;s.onmessage=e=>{this.onReceiveMessageCallback(t,e.data)},s.onopen=()=>{this.onReceiveChannelStateChange(t)},s.onclose=()=>{this.onReceiveChannelStateChange(t)},this.receiveChannels.set(t,s)}onSendChannelStateChange(e){const t=this.sendChannels.get(e);t&&"open"===t.readyState&&this.measureLatency(e),t&&this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} send channel state changed for ${e}: ${t.readyState}`)}onReceiveChannelStateChange(e){const t=this.receiveChannels.get(e);t&&this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} receive channel state changed for ${e}: ${t.readyState}`)}generateUniqueId(){return Date.now().toString(36)+Math.random().toString(36).substr(2)}onCreateSessionDescriptionError(e){this.hamsters.habitat.debug&&console.error(`Hamsters.js ${this.hamsters.version} failed to create session description: ${e}`)}onAddIceCandidateError(e){this.hamsters.habitat.debug&&console.error(`Hamsters.js ${this.hamsters.version} failed to add ICE candidate: ${e}`)}}const distribute=Distribute;class Observable{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.data=Array.isArray(e)?[...e]:{...e},this.events={}}on(e,t){this.events[e]||(this.events[e]=[]),this.events[e].push(t)}emit(e){for(var t=arguments.length,s=new Array(t>1?t-1:0),r=1;r<t;r++)s[r-1]=arguments[r];this.events[e]&&this.events[e].forEach((e=>e(...s)))}set(e,t){if("string"==typeof e){const s=e.split(".");let r=this.data;for(let e=0;e<s.length-1;e++)r=r[s[e]];r[s[s.length-1]]=t}else"object"==typeof e&&(this.data[e]=t);this.emit("change",this.data)}setAll(e){this.data=e}get(e){return this.data[e]}push(){this.data.push(...arguments),this.emit("change",this.data)}pop(){const e=this.data.pop();return this.emit("change",this.data),e}shift(){const e=this.data.shift();return this.emit("change",this.data),e}splice(e,t){for(var s=arguments.length,r=new Array(s>2?s-2:0),a=2;a<s;a++)r[a-2]=arguments[a];const n=this.data.splice(e,t,...r);return this.emit("change",this.data),n}indexOf(e){return this.data.indexOf(e)}length(){return this.data.length}delete(e){Array.isArray(this.data)||(delete this.data[e],this.emit("change",this.data))}getData(){return this.data}}const observable=Observable;class hamstersjs{constructor(){this.version="5.6.3",this.run=this.hamstersRun.bind(this),this.promise=this.hamstersPromise.bind(this),this.init=this.initializeLibrary.bind(this),this.data={},this.pool={},this.scaffold={},this.habitat={},this.memoize={}}initializeLibrary(e){const t=performance.now();this.observable=observable,this.data=new data(this),this.pool=new pool(this),this.scaffold={legacy:new legacy.A,regular:new regular.A,shared:new shared.A},this.habitat=new habitat(this),this.memoize=new memoize(this,100),this.distribute=new distribute(this),this.processStartOptions(e),this.habitat.legacy||!0!==this.habitat.persistence||this.pool.spawnHamsters(this.habitat.maxThreads),this.maxThreads=this.habitat.maxThreads,this.habitat.relay&&(console.info(`Hamsters.js ${this.version} establishing connection to relay`),this.distribute.establishConnection());const s=performance.now();console.info(`Hamsters.js ${this.version} initialized using up to ${this.habitat.maxThreads} threads in ${s-t}ms`)}processStartOptions(e){if(void 0!==e)for(const t of Object.keys(e))this.habitat.keys.includes(t.toLowerCase())?this.habitat[t]=e[t]:"scaffold"===t?this.scaffold.custom=e[t]:this[t]=e[t];let t=void 0!==e&&void 0!==e.legacy;t&&(t=e.legacy),"function"!=typeof this.habitat.Worker||t||(this.habitat.legacy=this.habitat.isIE)}scheduleTask(e,t,s){return e.input.memoize?this.memoize.memoize((()=>this.pool.scheduleTask(e)))(e).then(t).catch(s):this.pool.scheduleTask(e).then(t).catch(s)}hamstersPromise(e,t){return new Promise(((s,r)=>{this.scheduleTask(new task(this,e,t),s,r)}))}hamstersRun(e,t,s,r){this.scheduleTask(new task(this,e,t),s,r)}}const hamsters_0=new hamstersjs;return __webpack_exports__=__webpack_exports__.default,__webpack_exports__})()));
//# sourceMappingURL=hamsters.web.min.js.map