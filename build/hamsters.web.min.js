!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.hamsters=e():t.hamsters=e()}(this,(()=>(()=>{"use strict";function __webpack_require__(t){var e,s=__webpack_module_cache__[t];return void 0!==s?s.exports:(e=__webpack_module_cache__[t]={exports:{}},__webpack_modules__[t](e,e.exports,__webpack_require__),e.exports)}var __webpack_exports__,legacy,regular,shared,__webpack_modules__={327:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{A:()=>__WEBPACK_DEFAULT_EXPORT__});class Legacy{constructor(hamsters){this.hamsters=hamsters,this.scaffold=(params,resolve,reject)=>{var rtn={data:[],dataType:void 0!==params.dataType?params.dataType:null};this.hamsters.habitat.reactNative&&(self.rtn=rtn),this.hamsters.habitat.node||this.hamsters.habitat.isIE?eval(params.hamstersJob):params.hamstersJob(),resolve(rtn.data)}}}const __WEBPACK_DEFAULT_EXPORT__=Legacy},386:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{A:()=>__WEBPACK_DEFAULT_EXPORT__});class Regular{constructor(){this.scaffold=function(){function handleDataType(t){return this.params.sharedArray||this.params.dataType&&(t.data=typedArrayFromBuffer(t.dataType,t.data)),getTransferableObjects(t)}function typedArrayFromBuffer(t,e){const s={Uint32:Uint32Array,Uint16:Uint16Array,Uint8:Uint8Array,Uint8clamped:Uint8ClampedArray,Int32:Int32Array,Int16:Int16Array,Int8:Int8Array,Float32:Float32Array,Float64:Float64Array};return s[t]?new s[t](e):e}function returnResponse(t,e){e&&e.length>0?postMessage(t,e):postMessage(t)}function getTransferableObjects(t){const e=new Set,s=["Int32Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Uint32Array","Float32Array","Float64Array"],i="undefined"!=typeof self?self:window,r=[...s,"ArrayBuffer","MessagePort","ImageBitmap","OffscreenCanvas"];for(const n in t)if(t.hasOwnProperty(n))for(const o of r)void 0!==i[o]&&t[n]instanceof i[o]&&(s.includes(o)?e.add(t[n].buffer):e.add(t[n]));return Array.from(e)}self.params={},self.rtn={},self.onmessage=function(message){this.params=message.data,this.rtn={data:[],dataType:void 0!==this.params.dataType?this.params.dataType:null,index:this.params.index},this.params.sharedBuffer&&(this.params.sharedArray=typedArrayFromBuffer(this.params.dataType,this.params.sharedBuffer)),eval(this.params.hamstersJob);const buffers=handleDataType(this.rtn);returnResponse(this.rtn,buffers)}.bind(this)}}}const __WEBPACK_DEFAULT_EXPORT__=Regular},817:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{A:()=>__WEBPACK_DEFAULT_EXPORT__});class Shared{constructor(){this.scaffold=function(){self.params={},self.rtn={},addEventListener("connect",(incomingConnection=>{var port=incomingConnection.ports[0];port.start(),port.addEventListener("message",(incomingMessage=>{this.params=incomingMessage.data,this.rtn={data:[],dataType:this.params.dataType},eval("("+this.params.hamstersJob+")")(),port.postMessage(this.rtn)}),!1)}),!1)}}}const __WEBPACK_DEFAULT_EXPORT__=Shared}},__webpack_module_cache__={};__webpack_require__.d=(t,e)=>{for(var s in e)__webpack_require__.o(e,s)&&!__webpack_require__.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:e[s]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),__webpack_require__.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),__webpack_exports__={},__webpack_require__.d(__webpack_exports__,{default:()=>hamsters});class Habitat{constructor(t){this.hamsters=t,this.debug=!1,this.importScripts=null,this.relay=null,this.memoize=!1,this.persistence=!0,this.browser=this.isBrowser(),this.webWorker=this.isWebWorker(),this.node=this.isNode(),this.reactNative=this.isReactNative(),this.shell=this.isShell(),this.transferable=this.supportsTransferableObjects(),this.atomics=this.supportsAtomicOperations(),this.proxies=this.supportsProxies(),this.isIE=this.isInternetExplorer(),this.selectHamsterWheel=this.selectHamsterWheel.bind(this),this.sharedWorker=this.locateSharedWorkerObject(),this.locateBlobBuilder=this.findAvailableBlobBuilder(),this.legacy=this.isLegacyEnvironment(),this.Worker=this.locateWorkerObject(),this.maxThreads=this.determineGlobalThreads(),this.keys=this.getHabitatKeys()}determineGlobalThreads(){let t=4;return this.browser&&void 0!==navigator.hardwareConcurrency&&(t=navigator.hardwareConcurrency,this.isFirefox()&&(t=t>20?20:t)),this.node&&"undefined"!=typeof os&&(t=os.cpus().length),t}isFirefox(){return"undefined"!=typeof navigator&&void 0!==navigator.userAgent&&-1!==navigator.userAgent.toLowerCase().indexOf("firefox")}locateWorkerObject(){return"undefined"!=typeof Worker&&Worker}locateSharedWorkerObject(){return"undefined"!=typeof SharedWorker&&SharedWorker}isBrowser(){return"object"==typeof window}isInternetExplorer(){return"undefined"!=typeof navigator&&void 0!==navigator.userAgent&&(-1!==navigator.userAgent.indexOf("MSIE ")||-1!==navigator.userAgent.indexOf("Trident/"))}isNode(){return"object"==typeof process&&!this.isWebWorker()&&!this.browser}isWebWorker(){return"function"==typeof importScripts&&!this.isReactNative()}isReactNative(){return"undefined"!=typeof navigator&&void 0!==navigator.product&&"ReactNative"===navigator.product}isShell(){return"undefined"==typeof navigator&&!this.isNode()&&!this.isWebWorker()&&!this.isReactNative()}isLegacyEnvironment(){let t=!this.Worker;return this.isWebWorker()&&void 0!==this.SharedWorker&&(t=!this.supportsSharedWorkers()),t}supportsSharedWorkers(){return"undefined"!=typeof SharedWorker}findAvailableBlobBuilder(){return"undefined"!=typeof BlobBuilder?BlobBuilder:"undefined"!=typeof WebKitBlobBuilder?WebKitBlobBuilder:"undefined"!=typeof MozBlobBuilder?MozBlobBuilder:"undefined"!=typeof MSBlobBuilder?MSBlobBuilder:"Environment does not support data blobs!"}createDataBlob(t){if("undefined"==typeof Blob){let e=new(this.locateBlobBuilder());return e.append([t],{type:"application/javascript"}),e.getBlob()}return new Blob([t],{type:"application/javascript"})}generateWorkerBlob(t){return URL.createObjectURL(this.createDataBlob(this.generateWorkerString(t)))}generateWorkerString(t){return`(${t.toString()})();`}supportsTransferableObjects(){return"undefined"!=typeof Uint8Array}supportsAtomicOperations(){return"undefined"!=typeof SharedArrayBuffer}supportsProxies(){return"undefined"!=typeof Proxy}selectHamsterWheel(){return this.hamsters.scaffold.custom?this.hamsters.scaffold.custom:this.isIE?this.hamsters.scaffold.legacy.scaffold:this.reactNative?"reactNativeHamster.js":this.node?"./node_modules/hamsters.js/build/common/node.js":"data:text/javascript,"+encodeURIComponent(this.generateWorkerString(this.hamsters.scaffold.regular.scaffold))}getHabitatKeys(){return["worker","sharedworker","legacy","proxies","reactnative","atomics","transferable","browser","shell","node","debug","persistence","importscripts","maxthreads","parentport","webworker","relay"]}}const habitat=Habitat;class Pool{constructor(t){this.hamsters=t,this.threads=new t.observable([]),this.running=new t.observable([]),this.pending=new t.observable([]),this.fetchHamster=this.getAvailableThread}addWorkToPending(t,e,s,i){this.hamsters.habitat.debug&&(e.scheduler.metrics.threads[e.scheduler.count].enqueued_at=Date.now()),this.pending.push({index:t,count:e.scheduler.count,task:e,resolve:s,reject:i})}processQueuedItem(t,e){return this.hamsters.habitat.debug&&(e.task.scheduler.metrics.threads[e.count].dequeued_at=Date.now()),this.runTask(t,e.index,e.task,e.resolve,e.reject)}getAvailableThread(t){return this.hamsters.habitat.persistence?this.threads.get(t):this.spawnHamster()}keepTrackOfThread(t,e){t.scheduler.workers.push(e),this.running.push(e)}spawnHamsters(t){for(;t>0;t--)this.threads.push(this.spawnHamster())}spawnHamster(){const{selectHamsterWheel:t,Worker:e}=this.hamsters.habitat;return new e(t())}prepareMeal(t,e){const s={array:e.input.array&&0!==e.input.array.length?this.hamsters.data.getSubArrayFromIndex(t,e.input.array):[],index:t};void 0!==e.scheduler.sharedBuffer&&(s.sharedBuffer=e.scheduler.sharedBuffer);const i=new Set(["array","threads","sharedArray"]);for(const t in e.input)e.input.hasOwnProperty(t)&&!i.has(t)&&(s[t]=e.input[t]);return s}runTask(t,e,s,i,r){let n=this.running.length();e.id=n;let o=this.prepareMeal(e,s);this.keepTrackOfThread(s,n),this.hamsters.habitat.legacy?this.hamsters.habitat.legacyWheel(this.hamsters.habitat,o,i,r):(this.hamsters.pool.trainHamster(e,s,n,t,i,r),this.hamsters.data.feedHamster(t,o)),s.scheduler.count+=1}hamsterWheel(t,e,s,i){if(this.hamsters.habitat.maxThreads<=this.running.length())return this.addWorkToPending(t,e,s,i);let r=this.fetchHamster(this.running.length());return this.runTask(r,t,e,s,i)}returnOutputAndRemoveTask(t,e){if(t.scheduler.sharedBuffer&&(t.output=this.hamsters.data.processDataType(t.input.dataType,t.scheduler.sharedBuffer)),t.input.aggregate&&(t.output=this.hamsters.data.aggregateThreadOutputs(t.output,t.input.dataType)),t.input.sort&&(t.output=this.hamsters.data.sortOutput(t.output,t.input.sort)),this.hamsters.habitat.debug){const e=Date.now(),s=t.scheduler.metrics.started_at;t.scheduler.metrics.completed_at=e,console.info(`Hamsters.js Task Completed In ${e-s}ms`)}t.input.distribute?e(t):e(t.output)}removeFromRunning(t,e){this.running.splice(this.running.indexOf(e),1),t.scheduler.workers.splice(t.scheduler.workers.indexOf(e),1)}processReturn(t,e,s,i){let r=s.data;t.reactNative?r=JSON.parse(s).data:void 0!==s.data.data&&(r=s.data.data),1!==i.scheduler.threads?this.hamsters.data.addThreadOutputWithIndex(i,e,r):i.output=r}setOnMessage(t,e,s,i){s.webWorker&&(t.port.onmessage=e,t.port.onmessageerror=i,t.port.onerror=i),s.node?(t.once("message",e),t.once("onmessageerror",i),t.once("error",i)):(t.onmessage=e,t.onmessageerror=i,t.error=i)}trainHamster(t,e,s,i,r,n){this.hamsters.pool.setOnMessage(i,(n=>(this.hamsters.pool.processReturn(this.hamsters.habitat,t,n,e),this.hamsters.pool.removeFromRunning(e,s),0===e.scheduler.workers.length&&e.scheduler.count===e.scheduler.threads&&this.hamsters.pool.returnOutputAndRemoveTask(e,r),0!==this.hamsters.pool.pending.length()?this.hamsters.pool.processQueuedItem(i,this.hamsters.pool.pending.shift()):this.hamsters.habitat.persistence?void 0:i.terminate())),this.hamsters.habitat,n)}scheduleTask(t,e,s){if(t.input.distribute&&"task-response"!==t.type)this.hamsters.distribute.distributeTask(t,e,s);else{let i=0;for(;i<t.scheduler.threads;)this.hamsterWheel(t.scheduler.indexes[i],t,e,s),i+=1}}}const pool=Pool;class Data{constructor(t){this.hamsters=t,this.getSubArrayFromIndex=this.getSubArrayUsingIndex.bind(this),this.getSubArrayIndexes=this.calculateIndexes.bind(this),this.sortOutput=this.sortTaskOutput.bind(this),this.aggregateThreadOutputs=this.aggregateThreadOutputs.bind(this),this.processDataType=this.typedArrayFromBuffer,this.prepareFunction=this.prepareWorkerTask.bind(this),this.feedHamster=this.messageWorkerThread.bind(this),this.getBufferSize=this.getBufferSize,this.createSharedBuffer=this.createSharedBuffer.bind(this),this.getDataType=this.getDataType,this.setupSharedArrayBuffer=this.setupSharedArrayBuffer.bind(this)}messageWorkerThread(t,e){return this.hamsters.habitat.reactNative?t.postMessage(JSON.stringify(e)):t.postMessage(e,this.hamsters.data.getTransferableObjects(e))}getTransferableObjects(t){const e=[],s=[],i=["Int32Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Uint32Array","Float32Array","Float64Array"],r=["ArrayBuffer","MessagePort","ImageBitmap","OffscreenCanvas"],n="undefined"!=typeof window?window:__webpack_require__.g;for(const o in t){for(const s of i)if(void 0!==n[s]&&t[o]instanceof n[s]){e.push(t[o].buffer);break}for(const e of r)if(void 0!==n[e]&&t[o]instanceof n[e]){s.push(t[o]);break}}return e.concat(s)}typedArrayFromBuffer(t,e){const s={Uint32:Uint32Array,Uint16:Uint16Array,Uint8:Uint8Array,Uint8clamped:Uint8ClampedArray,Int32:Int32Array,Int16:Int16Array,Int8:Int8Array,Float32:Float32Array,Float64:Float64Array};return s[t]?new s[t](e):e}prepareWorkerTask(t){let e=String(t),s=e.trim().startsWith("async");return t=e.substring(e.indexOf("{")+1,e.lastIndexOf("}")),s?`(async () => {\n        ${t}\n      })();`:t}sortTaskOutput(t,e){switch(e){case"desc":case"asc":return Array.prototype.sort.call(t,(function(t,s){return"asc"===e?t-s:s-t}));case"ascAlpha":return t.sort();case"descAlpha":return t.reverse();default:return t}}getBufferSize(t){return t.byteLength}createSharedBuffer(t){const e=this.getBufferSize(t),s=new SharedArrayBuffer(e);return new t.constructor(s).set(t),s}setupSharedArrayBuffer(t){return this.createSharedBuffer(t)}aggregateThreadOutputs(t,e){if(!e)return t.reduce((function(t,e){return t.concat(e)}));let s=0,i=t.length,r=0;for(;s<i;s+=1)r+=t[s].length;let n=this.processDataType(e,r),o=0;for(s=0;s<i;s+=1)n.set(t[s],o),o+=t[s].length;return n}addThreadOutputWithIndex(t,e,s){let i=0;const r=s.length;for(;i<r;i++)t.output[e.start+i]=s[i]}calculateIndexes(t,e){if(1===e)return[{start:0,end:t.length-1}];const s=[],i=Math.floor(t.length/e);let r=0;for(let t=0;t<e;t++){const t=r+i-1;s.push({start:r,end:t}),r=t+1}return r<t.length&&(s[e-1].end=t.length-1),s}getTransferList(t){const e={},s=t.input;return Object.keys(s).forEach((i=>{Array.isArray(s[i])&&(e[i]=s[i],t.input[i]=null,s[i]="Awaiting Transfer")})),{hamsterFood:s,transferList:e,task:t,transferCount:Object.keys(e).length}}getSubArrayUsingIndex(t,e){return e.slice(t.start,t.end+1)}}const data=Data;class Task{constructor(t,e,s){this.input=e,this.type="task-local",this.output=[],this.scheduler={count:0,threads:e.threads||1,transfers:{request:0,send:0},workers:[]},t.habitat.legacy?this.setupLegacyTask(t,s):this.setupModernTask(t,e,s),t.habitat.debug&&this.setupDebugMetrics()}setupLegacyTask(t,e){this.scheduler.threads=1,t.habitat.node||t.habitat.isIE||(this.input.hamstersJob=e)}setupModernTask(t,e,s){this.input.hamstersJob=t.habitat.legacy?s:t.data.prepareFunction(s),e.sharedArray&&t.habitat.atomics?(this.scheduler.indexes=e.indexes||t.data.getSubArrayIndexes(e.sharedArray,this.scheduler.threads),this.scheduler.sharedBuffer=t.data.setupSharedArrayBuffer(e.sharedArray),this.input.sharedArray=[]):this.scheduler.indexes=e.indexes||t.data.getSubArrayIndexes(e.array,this.scheduler.threads)}setupDebugMetrics(){this.scheduler.metrics={created_at:Date.now(),started_at:Date.now(),completed_at:null,threads:this.setupThreadMetrics()}}setupThreadMetrics(){let t=0,e=[];for(;t<this.scheduler.threads;)e.push({created_at:Date.now(),started_at:null,enqueued_at:null,dequeued_at:null,completed_at:null}),t+=1;return e}}const task=Task;legacy=__webpack_require__(327),regular=__webpack_require__(386),shared=__webpack_require__(817);class NodeStore{constructor(t){this.maxSize=t,this.cache=new Map}get(t){if(this.cache.has(t)){const e=this.cache.get(t);return this.cache.delete(t),this.cache.set(t,e),Promise.resolve(e)}return Promise.resolve(null)}set(t,e){if(this.cache.size>=this.maxSize){const t=this.cache.keys().next().value;this.cache.delete(t)}return this.cache.set(t,e),Promise.resolve()}clear(){return this.cache.clear(),Promise.resolve()}}const stores_NodeStore=NodeStore;class WebStore{constructor(t,e,s){this.dbName=t,this.storeName=e,this.maxSize=s,this.db=null,this.initDB()}initDB(){const t=this,e=indexedDB.open(this.dbName,1);e.onerror=function(t){console.error("Error opening database:",t.target.error)},e.onupgradeneeded=function(e){const s=e.target.result;if(!s.objectStoreNames.contains(t.storeName)){const e=s.createObjectStore(t.storeName,{keyPath:"key"});e.createIndex("by_key","key",{unique:!0}),e.createIndex("by_timestamp","timestamp")}},e.onsuccess=function(e){t.db=e.target.result}}get(t){const e=this;return new Promise((function(s,i){if(!e.db)return console.error("Database not initialized"),void s(null);const r=e.db.transaction([e.storeName],"readonly").objectStore(e.storeName).get(t);r.onsuccess=function(r){const n=r.target.result;n?e.updateTimestamp(t).then((()=>s(n.value))).catch(i):s(null)},r.onerror=function(t){i(t.target.error)}}))}set(t,e){const s=this;return new Promise((function(i,r){if(!s.db)return console.error("Database not initialized"),void i();s.checkSize().then((()=>{const n=s.db.transaction([s.storeName],"readwrite").objectStore(s.storeName).put({key:t,value:e,timestamp:Date.now()});n.onsuccess=function(){i()},n.onerror=function(t){r(t.target.error)}})).catch(r)}))}clear(){const t=this;return new Promise((function(e,s){if(!t.db)return console.error("Database not initialized"),void e();const i=t.db.transaction([t.storeName],"readwrite").objectStore(t.storeName).clear();i.onsuccess=function(){e()},i.onerror=function(t){s(t.target.error)}}))}checkSize(){const t=this;return new Promise((function(e,s){const i=t.db.transaction([t.storeName],"readonly").objectStore(t.storeName).count();i.onsuccess=function(){i.result>=t.maxSize?t.evictOldest().then(e).catch(s):e()},i.onerror=function(t){s(t.target.error)}}))}evictOldest(){const t=this;return new Promise((function(e,s){const i=t.db.transaction([t.storeName],"readwrite").objectStore(t.storeName).index("by_timestamp").openCursor(null,"next");i.onsuccess=function(t){const s=t.target.result;s?s.delete().onsuccess=function(){e()}:e()},i.onerror=function(t){s(t.target.error)}}))}updateTimestamp(t){const e=this;return new Promise((function(s,i){const r=e.db.transaction([e.storeName],"readwrite").objectStore(e.storeName),n=r.get(t);n.onsuccess=function(t){const e=t.target.result;e?(e.timestamp=Date.now(),r.put(e).onsuccess=function(){s()}):s()},n.onerror=function(t){i(t.target.error)}}))}}const stores_WebStore=WebStore;class Memoize{constructor(t,e){this.hamsters=t,this.store=this.hamsters.habitat.node?new stores_NodeStore(e):new stores_WebStore("hamstersjs","cacheStore",e)}memoize(t){const e=this;return function(s){const i=e.generateTaskKey(s);return new Promise((function(r,n){e.store.get(i).then((function(o){null!==o?r(o):e.applyFunc(t,s).then((function(t){e.store.set(i,t).then((function(){r(t)})).catch(n)})).catch(n)})).catch(n)}))}}generateTaskKey(t){const e=JSON.stringify({input:t.input});return this.hashCode(e)}hashCode(t){let e,s,i=0;if(0===t.length)return i;for(e=0;e<t.length;e++)s=t.charCodeAt(e),i=(i<<5)-i+s,i|=0;return i.toString()}applyFunc(t,e){return new Promise(((s,i)=>{try{s(t.apply(null,e))}catch(t){i(t)}}))}}const memoize=Memoize;class Distribute{constructor(t){this.hamsters=t,this.localConnection=null,this.remoteConnections=new t.observable({}),this.clientInfo=new t.observable({}),this.sendChannels=new t.observable({}),this.pcConstraint=null,this.ws=null,this.clientId=null,this.pendingPromises=new Map,this.pendingTasks=new t.observable({}),this.pendingTransfers=new t.observable({}),this.awaitingTransfers=new t.observable({}),this.lastRequestedTransfers=new t.observable({}),this.pendingOutputs=new t.observable({}),this.returnDistributedOutput=this.sendDataResponse.bind(this),this.establishConnection=this.initWebSocket.bind(this),this.lastHeartbeat={},this.heartBeatInterval=3e4,this.deletedPromises=[],this.heartBeatTimeout={},this.messageCounter=0,this.generatedMessageIds=[],this.promiseTimeoutDuration=6e4}initWebSocket(){this.ws=new WebSocket(`${this.hamsters.habitat.relay}`),this.ws.onopen=()=>{console.info(`Hamsters.js ${this.hamsters.version} connection established`),this.ws.send(JSON.stringify({type:"register",logicalCores:this.hamsters.maxThreads})),this.sendHeartBeat(this.heartBeatInterval),this.startPromiseCleanupInterval(this.promiseTimeoutDuration)},this.ws.onmessage=t=>{const e=JSON.parse(t.data);this.handleWebSocketMessage(e)},this.ws.onerror=t=>{this.hamsters.habitat.debug&&console.error(`Hamsters.js ${this.hamsters.version} connection error:`,t)},this.ws.onclose=()=>{this.hamsters.habitat.debug&&console.info(`Hamsters.js ${this.hamsters.version} connection closed. Reconnecting...`),this.establishConnection()}}handleWebSocketMessage(t){const e={register:this.handleClientReconnect.bind(this),"update-client-list":this.updateClientList.bind(this),offer:this.handleOffer.bind(this),answer:this.handleAnswer.bind(this),candidate:this.handleCandidate.bind(this)}[t.type];e?e(t):this.hamsters.habitat.debug&&console.info(`Hamsters.js ${this.hamsters.version} unknown message type: ${t.type}`)}sendHeartBeat(t){this.heartBeatTimeout=setInterval((()=>{this.ws.send(JSON.stringify({type:"heartbeat"})),this.lastHeartbeat=Date.now()}),t)}updateClientList(t){const e=t.clients,s=new Set(e.map((t=>t.id)));e.forEach((t=>{t.id===this.clientId||this.remoteConnections.get(t.id)||this.createConnection(t.id)}));const i=this.remoteConnections.getData();Object.keys(i).forEach((t=>{s.has(t)||this.handleClientDisconnect(t)}))}handleClientDisconnect(t){this.remoteConnections.get(t)&&(this.remoteConnections.get(t).close(),this.remoteConnections.delete(t,"peer")),this.sendChannels.get(t)&&(this.sendChannels.get(t).close(),this.sendChannels.delete(t,"channel")),this.clientInfo.delete(t)}handleClientReconnect(t){const e=t.id;this.clientId!==e?(this.handleClientDisconnect(e),this.clientId=e):this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} reconnected with same ID`)}createConnection(t){if(t===this.clientId||this.remoteConnections.get(t))return;const e=new RTCPeerConnection({iceServers:[{urls:"stun:stun.l.google.com:19302"}]},this.pcConstraint);e.onicecandidate=e=>{e.candidate&&this.ws.send(JSON.stringify({type:"candidate",target:t,from:this.clientId,logicalCores:this.hamsters.maxThreads,userAgent:navigator.userAgent,candidate:e.candidate}))},e.ondatachannel=e=>{this.dataChannelCallback(e,t)},this.findOrCreateChannel(t,e),this.remoteConnections.set(t,e),e.createOffer().then((s=>{e.setLocalDescription(s),this.ws.send(JSON.stringify({type:"offer",target:t,offer:s}))})).catch(this.onCreateSessionDescriptionError.bind(this))}handleOffer(t){const e=t.from;if(console.log("WE HAVE A OFFER ",t),!this.remoteConnections.get(e)){const s=new RTCPeerConnection({iceServers:[{urls:"stun:stun.l.google.com:19302"}]},this.pcConstraint);s.onicecandidate=t=>{t.candidate&&this.ws.send(JSON.stringify({type:"candidate",target:e,logicalCores:this.hamsters.maxThreads,userAgent:navigator.userAgent,candidate:t.candidate}))},s.ondatachannel=t=>{this.dataChannelCallback(t,e)},s.setRemoteDescription(new RTCSessionDescription(t.offer)).then((()=>s.createAnswer())).then((t=>(this.ws.send(JSON.stringify({type:"answer",target:e,logicalCores:this.hamsters.maxThreads,userAgent:navigator.userAgent,answer:t})),s.setLocalDescription(t)))).catch(this.onCreateSessionDescriptionError.bind(this)),this.remoteConnections.set(e,s,"peer"),this.findOrCreateChannel(e,s)}}findOrCreateChannel(t,e){let s=this.sendChannels.get(t);if(!s){const i={ordered:!0,maxRetransmits:3,id:Math.floor(65536*Math.random())};s=e.createDataChannel("hamstersjs",i),s.onopen=()=>{this.onSendChannelStateChange(t)},s.onclose=()=>{this.onSendChannelStateChange(t)},s.onmessage=e=>{this.onReceiveMessageCallback(t,e.data)},this.sendChannels.set(t,s,"channel")}return s}dataChannelCallback(t,e){const s=t.channel,i=e;s.onmessage=t=>{this.onReceiveMessageCallback(i,t.data)},this.sendChannels.set(i,s)}storeClientConnectionInfo(t){const e={logicalCores:t.logicalCores,userAgent:t.userAgent};this.clientInfo.set(t.from,e)}handleAnswer(t){this.storeClientConnectionInfo(t);const e=this.remoteConnections.get(t.from);e.setRemoteDescription(new RTCSessionDescription(t.answer)),this.remoteConnections.set(t.from,e)}handleCandidate(t){let e=this.remoteConnections.get(t.from);e||(this.storeClientConnectionInfo(t),e=this.remoteConnections.get(t.from)),e.addIceCandidate(new RTCIceCandidate(t.candidate)).catch(this.onAddIceCandidateError.bind(this)),this.remoteConnections.set(t.from,e)}distributeTask(t,e,s){const i=t.input.client||this.getDistributedClient();if(!i)return this.hamsters.habitat.debug&&console.error(`Hamsters.js ${this.hamsters.version} no target client found.`),void s("No target client found.");const r=this.generateUniqueId(),n=this.hamsters.data.getTransferList(t),o={hamsterFood:n.hamsterFood,task:n.task,messageId:r,type:"task-request"};this.pendingPromises.has(i)||this.pendingPromises.set(i,new Map),this.pendingPromises.get(i).set(r,{resolve:e,reject:s,state:"pending"}),n.transferCount>0&&this.pendingTransfers.set(r,n.transferList),this.sendData({targetClient:i,data:o})}getDistributedClient(){const t=Object.keys(this.sendChannels.getData());if(0===t.length)return this.hamsters.habitat.debug&&console.warn(`Hamsters.js ${this.hamsters.version} no send channels available.`),null;let e=1/0,s=null;return t.forEach((t=>{const i=this.sendChannels.get(t),r=this.clientInfo.get(t);"open"===i.readyState&&r&&r.latency<e&&(e=r.latency,s=t)})),s}initializeDistributedTask(t,e,s){const i=Object.keys(e.hamsterFood).filter((t=>"Awaiting Transfer"===e.hamsterFood[t])).reduce(((t,e)=>(t[e]="Awaiting Transfer",t)),{});if(Object.keys(i).length>0){let e=this.awaitingTransfers.get(t);e||(e=[]),e.push({messageId:s,transferList:i}),this.awaitingTransfers.set(t,e),this.requestNextTransfer(t,s)}else this.runDistributedTask(e,t)}requestNextTransfer(t,e){const s=this.lastRequestedTransfers.get(t);let i=null;if(s&&(i=s.find((t=>t.messageId===e)),i))return void console.info("We already requested this transfer for this task");const r=this.awaitingTransfers.get(t);if(r){const s=r.find((t=>t.messageId===e));s&&this.requestTransferFromList(s,e,t)}}requestTransferFromList(t,e,s){const i=Object.keys(t.transferList);if(i.length>0){const r=i.find((e=>"Awaiting Transfer"===t.transferList[e]));r&&(this.updateTransferStatus(s,e,r,"Requested Transfer"),this.requestDataTransfer(r,e,s))}}updateTransferStatus(t,e,s,i){const r=this.awaitingTransfers.get(t);if(!r)return void console.error(`Hamsters.js ${this.hamsters.version} no awaiting transfers found for ${t}`);const n=r.find((t=>t.messageId===e));n?(n.transferList[s]=i,this.awaitingTransfers.set(t,r)):console.error(`Hamsters.js ${this.hamsters.version} no awaiting transfer found for messageId ${e}`)}handleTransferResponse(t,e){let s=this.lastRequestedTransfers.get(t);if(!s||0===s.length)return void console.error(`Hamsters.js ${this.hamsters.version} received transfer response but no transfer was requested for ${t}`);const i=s[0],r=i.key,n=i.messageId||null,o=i.responseId||null;if(o){const s=this.pendingPromises.get(t);if(s){for(const[i,n]of s)if(n.responseId===o){const o=this.convertFromArrayBuffer(e,r);n.resolve(o),s.delete(i),0===s.size&&this.pendingPromises.delete(t);break}}else console.warn(`Hamsters.js ${this.hamsters.version} no pending promises found for ${t}`)}else{const s=this.pendingTasks.get(t);if(s){const i=s.findIndex((t=>t.messageId===n));if(i>-1){const o=s[i];o.hamsterFood[r]=this.convertFromArrayBuffer(e,r);Object.values(o.hamsterFood).some((t=>"Awaiting Transfer"===t))?this.requestNextTransfer(t,n):(s.splice(i,1),0===s.length?this.pendingTasks.delete(t):this.pendingTasks.set(t,s),this.runDistributedTask(o,t))}else console.warn(`Hamsters.js ${this.hamsters.version} no pending task found for targetClient: ${t} and messageId: ${n}`)}else console.warn(`Hamsters.js ${this.hamsters.version} no pending task found for targetClient: ${t} and messageId: ${n}`)}s=s.slice(1),0===s.length?this.lastRequestedTransfers.delete(t):this.lastRequestedTransfers.set(t,s),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} processed transfer response for ${r} from ${t}`)}measureLatency(t){const e=performance.now();this.sendPing(t,e)}sendPing(t,e){const s=this.sendChannels.get(t);s&&"open"===s.readyState&&s.send(JSON.stringify({type:"ping",startTime:e,threads:this.hamsters.maxThreads}))}handlePing(t,e,s){const i=this.sendChannels.get(t);if(i&&"open"===i.readyState){i.send(JSON.stringify({type:"pong",startTime:e,threads:this.hamsters.maxThreads})),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} sent pong to ${t}`);const r=this.clientInfo.get(t);s&&(r.logicalCores=s,this.clientInfo.set(t,r))}}handlePong(t,e,s){const i=performance.now()-e,r=this.clientInfo.get(t)||{};r.latency=i,r.logicalCores=s,this.clientInfo.set(t,r),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} received pong from ${t} with latency: ${i.toFixed(2)}ms`)}runDistributedTask(t,e){let s=t.task;s.targetClient=e,s.messageId=t.messageId,s.input=t.hamsterFood,s.type="task-response",console.log("RUNNING DISTRIBUTED TASK"),this.hamsters.scheduleTask(s,this.returnDistributedOutput,this.returnDistributedOutput)}sendDataResponse(t){const{targetClient:e,messageId:s,output:i}=t,r=this.generateUniqueId();this.initializeOutputTransfer(e,i,s,r)}initializeOutputTransfer(t,e,s,i){this.pendingOutputs.set(i,{targetClient:t,output:e,messageId:s});const r={type:"task-response",messageId:s,responseId:i,awaitingTransfers:!0};this.sendData({targetClient:t,data:r}),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} initialized output transfer for ${t} (responseId: ${i})`)}handleOutputTransferRequest(t,e){const{responseId:s}=e,i=this.pendingOutputs.get(s);if(i&&i.targetClient===t){const e=this.getArrayBuffer(i.output);this.sendBlobData({targetClient:t,data:e,dataType:"arrayBuffer"}),this.pendingOutputs.delete(s),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} sent output transfer for ${t} (responseId: ${s})`)}else console.error(`Hamsters.js ${this.hamsters.version} received unexpected output transfer request for ${t}`)}getArrayBuffer(t){return ArrayBuffer.isView(t)?t.buffer:t instanceof ArrayBuffer?t:new Uint8Array(t).buffer}convertFromArrayBuffer(t,e){const s=new Uint8Array(t);if(this.hamsters.habitat.node){const t=new ArrayBuffer(s.byteLength),e=new Uint8Array(t);return e.set(s),e}return s}sendData(t){let{targetClient:e,data:s}=t;const i=this.sendChannels.get(e);i&&"open"===i.readyState?(i.send(JSON.stringify(s)),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} sent data to: ${e}`)):this.hamsters.habitat.debug&&console.error(`Hamsters.js ${this.hamsters.version} send channel is not open for targetClient: ${e}`)}sendBlobData(t){let{targetClient:e,data:s,dataType:i}=t;const r=this.sendChannels.get(e);r&&"open"===r.readyState?(r.send(s),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} sent blob data to: ${e}`)):this.hamsters.habitat.debug&&console.error(`Hamsters.js ${this.hamsters.version} send channel is not open for targetClient: ${e}`)}async blobToArrayBuffer(t){if("function"==typeof fetch){const e=new Response(t);return await e.arrayBuffer()}throw new Error("Fetch API is not supported in this environment.")}async onReceiveMessageCallback(t,e){if(e instanceof Blob&&(e=await this.blobToArrayBuffer(e)),e instanceof ArrayBuffer)this.handleTransferResponse(t,e);else if("string"==typeof e){let s;try{s=JSON.parse(e),this.handleIncomingMessage(t,s)}catch(t){console.error(`Hamsters.js ${this.hamsters.version} error parsing message:`,t)}}else console.log("Received unexpected data type:",t,e)}handleIncomingMessage(t,e){const s={"transfer-request":this.fulfillTransferRequest.bind(this),"task-request":this.handleTaskRequest.bind(this),"transfer-response":this.processTransferResponse.bind(this),"output-transfer-request":this.handleOutputTransferRequest.bind(this),"task-response":this.handleTaskResponse.bind(this),ping:(t,e)=>this.handlePing(t,e.startTime,e.threads),pong:(t,e)=>this.handlePong(t,e.startTime,e.threads)}[e.type];s?s(t,e):console.log(`Hamsters.js ${this.hamsters.version} unknown message received from: ${t}`)}handleTaskRequest(t,e){let s=this.pendingTasks.get(t);s||(s=[]),s.push(e),this.pendingTasks.set(t,s);Object.values(e.hamsterFood).some((t=>"Awaiting Transfer"===t))?this.initializeDistributedTask(t,e,e.messageId):this.runDistributedTask(e,t)}startPromiseCleanupInterval(t){setInterval((()=>this.cleanupStalePendingPromises()),t)}cleanupStalePendingPromises(){const t=Date.now();for(const[e,s]of this.pendingPromises){for(const[e,i]of s)t-i.timestamp>this.promiseTimeoutDuration&&(i.reject(new Error("Task timed out")),s.delete(e));0===s.size&&this.pendingPromises.delete(e)}}handleTaskResponse(t,e){const{messageId:s,responseId:i,awaitingTransfers:r,output:n}=e,o=this.pendingPromises.get(t);if(o&&o.has(s)){const e=o.get(s);r&&i?(e.state="awaitingTransfer",e.responseId=i,this.requestOutputTransfer(t,i,s)):(e.resolve(n),o.delete(s),0===o.size&&this.pendingPromises.delete(t))}else console.warn(`Received a message from ${t} but no matching promise found with messageId ${s}`)}requestOutputTransfer(t,e,s){let i=this.lastRequestedTransfers.get(t);i||(i=[]);const r={type:"output-transfer-request",key:"output",responseId:e,messageId:s};i.push(r),this.lastRequestedTransfers.set(t,i),this.sendData({targetClient:t,data:r})}requestDataTransfer(t,e,s){let i=this.lastRequestedTransfers.get(s);i||(i=[]);const r={type:"transfer-request",key:t,messageId:e};i.push(r),this.lastRequestedTransfers.set(s,i),this.sendData({targetClient:s,data:r});const n=this.awaitingTransfers.get(s);n&&n.messageId===e&&(n.transfers[t]="Requested Transfer",this.awaitingTransfers.set(s,n)),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} requested transfer for ${t} from ${s} (messageId: ${e})`)}fulfillTransferRequest(t,e){const{key:s,messageId:i,responseId:r}=e,n=r||i,o=this.pendingTransfers.get(n);if(o&&o[s]){const e=o[s],a=this.getArrayBuffer(e);this.sendBlobData({targetClient:t,data:a,dataType:"arrayBuffer"}),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} sent transfer response for ${s} (${r?"output":"input"}) to ${t} (messageId: ${i})`),delete o[s],0===Object.keys(o).length&&this.pendingTransfers.delete(n)}else console.error(`No pending transfer found for ${s} (${r?"output":"input"}) for ${t} (messageId: ${i})`)}processTransferResponse(t,e){const{key:s,data:i,messageId:r,responseId:n}=e;if(n){const t=this.pendingPromises.get(r);t?(t.resolve(i),this.pendingPromises.delete(r)):console.warn(`Hamsters.js ${this.hamsters.version} no pending promise found for messageId: ${r}`)}else{const e=this.pendingTasks.get(t);if(e){const n=e.findIndex((t=>t.messageId===r));if(n>-1){const o=e[n];o.hamsterFood[s]=this.convertFromArrayBuffer(i);Object.values(o.hamsterFood).some((t=>"Awaiting Transfer"===t))?this.requestNextTransfer(t,r):(e.splice(n,1),0===e.length?this.pendingTasks.delete(t):this.pendingTasks.set(t,e),this.runDistributedTask(o,t))}else console.warn(`Hamsters.js ${this.hamsters.version} no pending task found for targetClient: ${t} and messageId: ${r}`)}else console.warn(`Hamsters.js ${this.hamsters.version} no pending task found for targetClient: ${t} and messageId: ${r}`)}const o=this.lastRequestedTransfers.get(t);o&&(o.shift(),0===o.length?this.lastRequestedTransfers.delete(t):this.lastRequestedTransfers.set(t,o)),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} processed transfer response for ${s} from ${t}`)}onSendChannelStateChange(t){const e=this.sendChannels.get(t);e&&"open"===e.readyState&&this.measureLatency(t),e&&this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} send channel state changed for ${t}: ${e.readyState}`)}generateUniqueId(){const t=Date.now().toString(36),e=Math.random().toString(36).substr(2,5);return this.messageCounter=(this.messageCounter+1)%1e6,`${t}-${e}-${this.messageCounter.toString(36).padStart(5,"0")}`}onCreateSessionDescriptionError(t){this.hamsters.habitat.debug&&console.error(`Hamsters.js ${this.hamsters.version} failed to create session description: ${t}`)}onAddIceCandidateError(t){this.hamsters.habitat.debug&&console.error(`Hamsters.js ${this.hamsters.version} failed to add ICE candidate: ${t}`)}}const distribute=Distribute;class Observable{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.data=Array.isArray(t)?[...t]:{...t},this.events={}}on(t,e){this.events[t]||(this.events[t]=[]),this.events[t].push(e)}emit(t){for(var e=arguments.length,s=new Array(e>1?e-1:0),i=1;i<e;i++)s[i-1]=arguments[i];this.events[t]&&this.events[t].forEach((t=>t(...s)))}emitEvents(t,e){"change"!==t&&this.emit(t,e),this.emit("change",e)}set(t,e){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"change";this.data[t];if("string"==typeof t){const s=t.split(".");let i=this.data;for(let t=0;t<s.length-1;t++)i=i[s[t]];i[s[s.length-1]]=e}else"object"==typeof t&&(this.data[t]=e);return this.emitEvents(s,this.data),e}setAll(t){this.data=t}get(t){return this.data[t]}push(){this.data.push(...arguments),this.emitEvents("change",this.data)}pop(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"change";const e=this.data.pop();return this.emitEvents(t,this.data),e}shift(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"change",e=this.data.shift();return this.emitEvents(t,this.data),e}splice(t,e){for(var s=arguments.length,i=new Array(s>2?s-2:0),r=2;r<s;r++)i[r-2]=arguments[r];const n=this.data.splice(t,e,...i);return this.emitEvents("change",this.data),n}indexOf(t){return this.data.indexOf(t)}length(){return this.data.length}delete(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"change";Array.isArray(this.data)||(delete this.data[t],this.emitEvents(e,this.data))}getData(){return this.data}}const observable=Observable;class hamstersjs{constructor(){this.version="5.6.3",this.run=this.hamstersRun.bind(this),this.promise=this.hamstersPromise.bind(this),this.init=this.initializeLibrary.bind(this),this.data={},this.pool={},this.scaffold={},this.habitat={},this.memoize={}}initializeLibrary(t){const e=performance.now();this.observable=observable,this.data=new data(this),this.pool=new pool(this),this.scaffold={legacy:new legacy.A,regular:new regular.A,shared:new shared.A},this.habitat=new habitat(this),this.memoize=new memoize(this,100),this.distribute=new distribute(this),this.processStartOptions(t),this.habitat.legacy||!0!==this.habitat.persistence||this.pool.spawnHamsters(this.habitat.maxThreads),this.maxThreads=this.habitat.maxThreads,this.habitat.relay&&(console.info(`Hamsters.js ${this.version} establishing connection to relay`),this.distribute.establishConnection());const s=performance.now();console.info(`Hamsters.js ${this.version} initialized using up to ${this.habitat.maxThreads} threads in ${s-e}ms`)}processStartOptions(t){if(void 0!==t)for(const e of Object.keys(t))this.habitat.keys.includes(e.toLowerCase())?this.habitat[e]=t[e]:"scaffold"===e?this.scaffold.custom=t[e]:this[e]=t[e];let e=void 0!==t&&void 0!==t.legacy;e&&(e=t.legacy),"function"!=typeof this.habitat.Worker||e||(this.habitat.legacy=this.habitat.isIE)}scheduleTask(t,e,s){if(t.input.memoize){return this.memoize.memoize((()=>this.pool.scheduleTask(t,e,s)))(t).then(e).catch(s)}return this.pool.scheduleTask(t,e,s)}hamstersPromise(t,e){return new Promise(((s,i)=>{this.scheduleTask(new task(this,t,e),s,i)}))}hamstersRun(t,e,s,i){this.scheduleTask(new task(this,t,e),s,i)}}const hamsters=new hamstersjs;return __webpack_exports__=__webpack_exports__.default,__webpack_exports__})()));
//# sourceMappingURL=hamsters.web.min.js.map