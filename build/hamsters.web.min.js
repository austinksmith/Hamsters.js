!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.hamsters=t():e.hamsters=t()}(this,(()=>(()=>{"use strict";var __webpack_modules__={327:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{A:()=>__WEBPACK_DEFAULT_EXPORT__});class Legacy{constructor(hamsters){this.hamsters=hamsters,this.scaffold=(params,resolve,reject)=>{var rtn={data:[],dataType:void 0!==params.dataType?params.dataType:null};this.hamsters.habitat.reactNative&&(self.rtn=rtn),this.hamsters.habitat.node||this.hamsters.habitat.isIE?eval(params.hamstersJob):params.hamstersJob(),resolve(rtn.data)}}}const __WEBPACK_DEFAULT_EXPORT__=Legacy},386:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{A:()=>__WEBPACK_DEFAULT_EXPORT__});class Regular{constructor(){this.scaffold=function(){function handleDataType(e){return this.params.sharedArray||this.params.dataType&&(e.data=typedArrayFromBuffer(e.dataType,e.data)),getTransferableObjects(e)}function typedArrayFromBuffer(e,t){const s={Uint32:Uint32Array,Uint16:Uint16Array,Uint8:Uint8Array,Uint8clamped:Uint8ClampedArray,Int32:Int32Array,Int16:Int16Array,Int8:Int8Array,Float32:Float32Array,Float64:Float64Array};return s[e]?new s[e](t):t}function returnResponse(e,t){t&&t.length>0?postMessage(e,t):postMessage(e)}function getTransferableObjects(e){const t=new Set,s=["Int32Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Uint32Array","Float32Array","Float64Array"],r="undefined"!=typeof self?self:window,a=[...s,"ArrayBuffer","MessagePort","ImageBitmap","OffscreenCanvas"];for(const n in e)if(e.hasOwnProperty(n))for(const i of a)void 0!==r[i]&&e[n]instanceof r[i]&&(s.includes(i)?t.add(e[n].buffer):t.add(e[n]));return Array.from(t)}self.params={},self.rtn={},self.onmessage=function(message){this.params=message.data,this.rtn={data:[],dataType:void 0!==this.params.dataType?this.params.dataType:null,index:this.params.index},this.params.sharedBuffer&&(this.params.sharedArray=typedArrayFromBuffer(this.params.dataType,this.params.sharedBuffer)),eval(this.params.hamstersJob);const buffers=handleDataType(this.rtn);returnResponse(this.rtn,buffers)}.bind(this)}}}const __WEBPACK_DEFAULT_EXPORT__=Regular},817:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{A:()=>__WEBPACK_DEFAULT_EXPORT__});class Shared{constructor(){this.scaffold=function(){self.params={},self.rtn={},addEventListener("connect",(incomingConnection=>{var port=incomingConnection.ports[0];port.start(),port.addEventListener("message",(incomingMessage=>{this.params=incomingMessage.data,this.rtn={data:[],dataType:this.params.dataType},eval("("+this.params.hamstersJob+")")(),port.postMessage(this.rtn)}),!1)}),!1)}}}const __WEBPACK_DEFAULT_EXPORT__=Shared}},__webpack_module_cache__={};function __webpack_require__(e){var t=__webpack_module_cache__[e];if(void 0!==t)return t.exports;var s=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](s,s.exports,__webpack_require__),s.exports}__webpack_require__.d=(e,t)=>{for(var s in t)__webpack_require__.o(t,s)&&!__webpack_require__.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:t[s]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__webpack_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);var __webpack_exports__={};__webpack_require__.d(__webpack_exports__,{default:()=>hamsters});class Habitat{constructor(e){this.hamsters=e,this.debug=!1,this.importScripts=null,this.relay=null,this.memoize=!1,this.persistence=!0,this.browser=this.isBrowser(),this.webWorker=this.isWebWorker(),this.node=this.isNode(),this.reactNative=this.isReactNative(),this.shell=this.isShell(),this.transferable=this.supportsTransferableObjects(),this.atomics=this.supportsAtomicOperations(),this.proxies=this.supportsProxies(),this.isIE=this.isInternetExplorer(),this.selectHamsterWheel=this.selectHamsterWheel.bind(this),this.sharedWorker=this.locateSharedWorkerObject(),this.locateBlobBuilder=this.findAvailableBlobBuilder(),this.legacy=this.isLegacyEnvironment(),this.Worker=this.locateWorkerObject(),this.maxThreads=this.determineGlobalThreads(),this.keys=this.getHabitatKeys()}determineGlobalThreads(){let e=4;return this.browser&&void 0!==navigator.hardwareConcurrency&&(e=navigator.hardwareConcurrency,this.isFirefox()&&(e=e>20?20:e)),this.node&&"undefined"!=typeof os&&(e=os.cpus().length),e}isFirefox(){return"undefined"!=typeof navigator&&void 0!==navigator.userAgent&&-1!==navigator.userAgent.toLowerCase().indexOf("firefox")}locateWorkerObject(){return"undefined"!=typeof Worker&&Worker}locateSharedWorkerObject(){return"undefined"!=typeof SharedWorker&&SharedWorker}isBrowser(){return"object"==typeof window}isInternetExplorer(){return"undefined"!=typeof navigator&&void 0!==navigator.userAgent&&(-1!==navigator.userAgent.indexOf("MSIE ")||-1!==navigator.userAgent.indexOf("Trident/"))}isNode(){return"object"==typeof process&&!this.isWebWorker()&&!this.browser}isWebWorker(){return"function"==typeof importScripts&&!this.isReactNative()}isReactNative(){return"undefined"!=typeof navigator&&void 0!==navigator.product&&"ReactNative"===navigator.product}isShell(){return"undefined"==typeof navigator&&!this.isNode()&&!this.isWebWorker()&&!this.isReactNative()}isLegacyEnvironment(){let e=!this.Worker;return this.isWebWorker()&&void 0!==this.SharedWorker&&(e=!this.supportsSharedWorkers()),e}supportsSharedWorkers(){return"undefined"!=typeof SharedWorker}findAvailableBlobBuilder(){return"undefined"!=typeof BlobBuilder?BlobBuilder:"undefined"!=typeof WebKitBlobBuilder?WebKitBlobBuilder:"undefined"!=typeof MozBlobBuilder?MozBlobBuilder:"undefined"!=typeof MSBlobBuilder?MSBlobBuilder:"Environment does not support data blobs!"}createDataBlob(e){if("undefined"==typeof Blob){let t=new(this.locateBlobBuilder());return t.append([e],{type:"application/javascript"}),t.getBlob()}return new Blob([e],{type:"application/javascript"})}generateWorkerBlob(e){return URL.createObjectURL(this.createDataBlob(this.generateWorkerString(e)))}generateWorkerString(e){return`(${e.toString()})();`}supportsTransferableObjects(){return"undefined"!=typeof Uint8Array}supportsAtomicOperations(){return"undefined"!=typeof SharedArrayBuffer}supportsProxies(){return"undefined"!=typeof Proxy}selectHamsterWheel(){return this.hamsters.scaffold.custom?this.hamsters.scaffold.custom:this.isIE?this.hamsters.scaffold.legacy.scaffold:this.reactNative?"reactNativeHamster.js":this.node?"./node_modules/hamsters.js/build/common/node.js":"data:text/javascript,"+encodeURIComponent(this.generateWorkerString(this.hamsters.scaffold.regular.scaffold))}getHabitatKeys(){return["worker","sharedworker","legacy","proxies","reactnative","atomics","transferable","browser","shell","node","debug","persistence","importscripts","maxthreads","parentport","webworker","relay"]}}const habitat=Habitat;class Pool{constructor(e){this.hamsters=e,this.threads=new e.observable([]),this.running=new e.observable([]),this.pending=new e.observable([]),this.fetchHamster=this.getAvailableThread}addWorkToPending(e,t,s,r){this.hamsters.habitat.debug&&(t.scheduler.metrics.threads[t.scheduler.count].enqueued_at=Date.now()),this.pending.push({index:e,count:t.scheduler.count,task:t,resolve:s,reject:r})}processQueuedItem(e,t){return this.hamsters.habitat.debug&&(t.task.scheduler.metrics.threads[t.count].dequeued_at=Date.now()),this.runTask(e,t.index,t.task,t.resolve,t.reject)}getAvailableThread(e){return this.hamsters.habitat.persistence?this.threads.get(e):this.spawnHamster()}keepTrackOfThread(e,t){e.scheduler.workers.push(t),this.running.push(t)}spawnHamsters(e){for(;e>0;e--)this.threads.push(this.spawnHamster())}spawnHamster(){const{selectHamsterWheel:e,Worker:t}=this.hamsters.habitat;return new t(e())}prepareMeal(e,t){const s={array:t.input.array&&0!==t.input.array.length?this.hamsters.data.getSubArrayFromIndex(e,t.input.array):[],index:e};void 0!==t.scheduler.sharedBuffer&&(s.sharedBuffer=t.scheduler.sharedBuffer);const r=new Set(["array","threads","sharedArray"]);for(const e in t.input)t.input.hasOwnProperty(e)&&!r.has(e)&&(s[e]=t.input[e]);return s}runTask(e,t,s,r,a){let n=this.running.length();t.id=n;let i=this.prepareMeal(t,s);this.keepTrackOfThread(s,n),this.hamsters.habitat.legacy?this.hamsters.habitat.legacyWheel(this.hamsters.habitat,i,r,a):(this.hamsters.pool.trainHamster(t,s,n,e,r,a),this.hamsters.data.feedHamster(e,i)),s.scheduler.count+=1}hamsterWheel(e,t,s,r){if(this.hamsters.habitat.maxThreads<=this.running.length())return this.addWorkToPending(e,t,s,r);let a=this.fetchHamster(this.running.length());return this.runTask(a,e,t,s,r)}returnOutputAndRemoveTask(e,t){if(e.scheduler.sharedBuffer&&(e.output=this.hamsters.data.processDataType(e.input.dataType,e.scheduler.sharedBuffer)),e.input.aggregate&&(e.output=this.hamsters.data.aggregateThreadOutputs(e.output,e.input.dataType)),e.input.sort&&(e.output=this.hamsters.data.sortOutput(e.output,e.input.sort)),this.hamsters.habitat.debug){const t=Date.now(),s=e.scheduler.metrics.started_at;e.scheduler.metrics.completed_at=t,console.info(`Hamsters.js Task Completed In ${t-s}ms`)}e.input.distribute?t(e):t(e.output)}removeFromRunning(e,t){this.running.splice(this.running.indexOf(t),1),e.scheduler.workers.splice(e.scheduler.workers.indexOf(t),1)}processReturn(e,t,s,r){let a=s.data;e.reactNative?a=JSON.parse(s).data:void 0!==s.data.data&&(a=s.data.data),1!==r.scheduler.threads?this.hamsters.data.addThreadOutputWithIndex(r,t,a):r.output=a}setOnMessage(e,t,s,r){s.webWorker&&(e.port.onmessage=t,e.port.onmessageerror=r,e.port.onerror=r),s.node?(e.once("message",t),e.once("onmessageerror",r),e.once("error",r)):(e.onmessage=t,e.onmessageerror=r,e.error=r)}trainHamster(e,t,s,r,a,n){this.hamsters.pool.setOnMessage(r,(n=>(this.hamsters.pool.processReturn(this.hamsters.habitat,e,n,t),this.hamsters.pool.removeFromRunning(t,s),0===t.scheduler.workers.length&&t.scheduler.count===t.scheduler.threads&&this.hamsters.pool.returnOutputAndRemoveTask(t,a),0!==this.hamsters.pool.pending.length()?this.hamsters.pool.processQueuedItem(r,this.hamsters.pool.pending.shift()):this.hamsters.habitat.persistence?void 0:r.terminate())),this.hamsters.habitat,n)}scheduleTask(e,t,s){if(e.input.distribute&&"task-response"!==e.type)this.hamsters.distribute.distributeTask(e,t,s);else{let r=0;for(;r<e.scheduler.threads;)this.hamsterWheel(e.scheduler.indexes[r],e,t,s),r+=1}}}const pool=Pool;class Data{constructor(e){this.hamsters=e,this.getSubArrayFromIndex=this.getSubArrayUsingIndex.bind(this),this.getSubArrayIndexes=this.calculateIndexes.bind(this),this.sortOutput=this.sortTaskOutput.bind(this),this.aggregateThreadOutputs=this.aggregateThreadOutputs.bind(this),this.processDataType=this.typedArrayFromBuffer,this.prepareFunction=this.prepareWorkerTask.bind(this),this.feedHamster=this.messageWorkerThread.bind(this),this.getBufferSize=this.getBufferSize,this.createSharedBuffer=this.createSharedBuffer.bind(this),this.getDataType=this.getDataType,this.setupSharedArrayBuffer=this.setupSharedArrayBuffer.bind(this)}messageWorkerThread(e,t){return this.hamsters.habitat.reactNative?e.postMessage(JSON.stringify(t)):e.postMessage(t,this.hamsters.data.getTransferableObjects(t))}getTransferableObjects(e){const t=[],s=[],r=["Int32Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Uint32Array","Float32Array","Float64Array"],a=["ArrayBuffer","MessagePort","ImageBitmap","OffscreenCanvas"],n="undefined"!=typeof window?window:__webpack_require__.g;for(const i in e){for(const s of r)if(void 0!==n[s]&&e[i]instanceof n[s]){t.push(e[i].buffer);break}for(const t of a)if(void 0!==n[t]&&e[i]instanceof n[t]){s.push(e[i]);break}}return t.concat(s)}typedArrayFromBuffer(e,t){const s={Uint32:Uint32Array,Uint16:Uint16Array,Uint8:Uint8Array,Uint8clamped:Uint8ClampedArray,Int32:Int32Array,Int16:Int16Array,Int8:Int8Array,Float32:Float32Array,Float64:Float64Array};return s[e]?new s[e](t):t}prepareWorkerTask(e){let t=String(e),s=t.trim().startsWith("async");return e=t.substring(t.indexOf("{")+1,t.lastIndexOf("}")),s?`(async () => {\n        ${e}\n      })();`:e}sortTaskOutput(e,t){switch(t){case"desc":case"asc":return Array.prototype.sort.call(e,(function(e,s){return"asc"===t?e-s:s-e}));case"ascAlpha":return e.sort();case"descAlpha":return e.reverse();default:return e}}getBufferSize(e){return e.byteLength}createSharedBuffer(e){const t=this.getBufferSize(e),s=new SharedArrayBuffer(t);return new e.constructor(s).set(e),s}setupSharedArrayBuffer(e){return this.createSharedBuffer(e)}aggregateThreadOutputs(e,t){if(!t)return e.reduce((function(e,t){return e.concat(t)}));let s=0,r=e.length,a=0;for(;s<r;s+=1)a+=e[s].length;let n=this.processDataType(t,a),i=0;for(s=0;s<r;s+=1)n.set(e[s],i),i+=e[s].length;return n}addThreadOutputWithIndex(e,t,s){let r=0;const a=s.length;for(;r<a;r++)e.output[t.start+r]=s[r]}calculateIndexes(e,t){if(1===t)return[{start:0,end:e.length-1}];const s=[],r=Math.floor(e.length/t);let a=0;for(let e=0;e<t;e++){const e=a+r-1;s.push({start:a,end:e}),a=e+1}return a<e.length&&(s[t-1].end=e.length-1),s}getTransferList(e){const t={},s=e.input;return Object.keys(s).forEach((r=>{Array.isArray(s[r])&&(t[r]=s[r],e.input[r]=null,s[r]="Awaiting Transfer")})),{hamsterFood:s,transferList:t,task:e,transferCount:Object.keys(t).length}}getSubArrayUsingIndex(e,t){return t.slice(e.start,e.end+1)}}const data=Data;class Task{constructor(e,t,s){this.input=t,this.type="task-local",this.output=[],this.scheduler={count:0,threads:t.threads||1,transfers:{request:0,send:0},workers:[]},e.habitat.legacy?this.setupLegacyTask(e,s):this.setupModernTask(e,t,s),e.habitat.debug&&this.setupDebugMetrics()}setupLegacyTask(e,t){this.scheduler.threads=1,e.habitat.node||e.habitat.isIE||(this.input.hamstersJob=t)}setupModernTask(e,t,s){this.input.hamstersJob=e.habitat.legacy?s:e.data.prepareFunction(s),t.sharedArray&&e.habitat.atomics?(this.scheduler.indexes=t.indexes||e.data.getSubArrayIndexes(t.sharedArray,this.scheduler.threads),this.scheduler.sharedBuffer=e.data.setupSharedArrayBuffer(t.sharedArray),this.input.sharedArray=[]):this.scheduler.indexes=t.indexes||e.data.getSubArrayIndexes(t.array,this.scheduler.threads)}setupDebugMetrics(){this.scheduler.metrics={created_at:Date.now(),started_at:Date.now(),completed_at:null,threads:this.setupThreadMetrics()}}setupThreadMetrics(){let e=0,t=[];for(;e<this.scheduler.threads;)t.push({created_at:Date.now(),started_at:null,enqueued_at:null,dequeued_at:null,completed_at:null}),e+=1;return t}}const task=Task;var legacy=__webpack_require__(327),regular=__webpack_require__(386),shared=__webpack_require__(817);class NodeStore{constructor(e){this.maxSize=e,this.cache=new Map}get(e){if(this.cache.has(e)){const t=this.cache.get(e);return this.cache.delete(e),this.cache.set(e,t),Promise.resolve(t)}return Promise.resolve(null)}set(e,t){if(this.cache.size>=this.maxSize){const e=this.cache.keys().next().value;this.cache.delete(e)}return this.cache.set(e,t),Promise.resolve()}clear(){return this.cache.clear(),Promise.resolve()}}const stores_NodeStore=NodeStore;class WebStore{constructor(e,t,s){this.dbName=e,this.storeName=t,this.maxSize=s,this.db=null,this.initDB()}initDB(){const e=this,t=indexedDB.open(this.dbName,1);t.onerror=function(e){console.error("Error opening database:",e.target.error)},t.onupgradeneeded=function(t){const s=t.target.result;if(!s.objectStoreNames.contains(e.storeName)){const t=s.createObjectStore(e.storeName,{keyPath:"key"});t.createIndex("by_key","key",{unique:!0}),t.createIndex("by_timestamp","timestamp")}},t.onsuccess=function(t){e.db=t.target.result}}get(e){const t=this;return new Promise((function(s,r){if(!t.db)return console.error("Database not initialized"),void s(null);const a=t.db.transaction([t.storeName],"readonly").objectStore(t.storeName).get(e);a.onsuccess=function(a){const n=a.target.result;n?t.updateTimestamp(e).then((()=>s(n.value))).catch(r):s(null)},a.onerror=function(e){r(e.target.error)}}))}set(e,t){const s=this;return new Promise((function(r,a){if(!s.db)return console.error("Database not initialized"),void r();s.checkSize().then((()=>{const n=s.db.transaction([s.storeName],"readwrite").objectStore(s.storeName).put({key:e,value:t,timestamp:Date.now()});n.onsuccess=function(){r()},n.onerror=function(e){a(e.target.error)}})).catch(a)}))}clear(){const e=this;return new Promise((function(t,s){if(!e.db)return console.error("Database not initialized"),void t();const r=e.db.transaction([e.storeName],"readwrite").objectStore(e.storeName).clear();r.onsuccess=function(){t()},r.onerror=function(e){s(e.target.error)}}))}checkSize(){const e=this;return new Promise((function(t,s){const r=e.db.transaction([e.storeName],"readonly").objectStore(e.storeName).count();r.onsuccess=function(){r.result>=e.maxSize?e.evictOldest().then(t).catch(s):t()},r.onerror=function(e){s(e.target.error)}}))}evictOldest(){const e=this;return new Promise((function(t,s){const r=e.db.transaction([e.storeName],"readwrite").objectStore(e.storeName).index("by_timestamp").openCursor(null,"next");r.onsuccess=function(e){const s=e.target.result;s?s.delete().onsuccess=function(){t()}:t()},r.onerror=function(e){s(e.target.error)}}))}updateTimestamp(e){const t=this;return new Promise((function(s,r){const a=t.db.transaction([t.storeName],"readwrite").objectStore(t.storeName),n=a.get(e);n.onsuccess=function(e){const t=e.target.result;t?(t.timestamp=Date.now(),a.put(t).onsuccess=function(){s()}):s()},n.onerror=function(e){r(e.target.error)}}))}}const stores_WebStore=WebStore;class Memoize{constructor(e,t){this.hamsters=e,this.store=this.hamsters.habitat.node?new stores_NodeStore(t):new stores_WebStore("hamstersjs","cacheStore",t)}memoize(e){const t=this;return function(s){const r=t.generateTaskKey(s);return new Promise((function(a,n){t.store.get(r).then((function(i){null!==i?a(i):t.applyFunc(e,s).then((function(e){t.store.set(r,e).then((function(){a(e)})).catch(n)})).catch(n)})).catch(n)}))}}generateTaskKey(e){const t=JSON.stringify({input:e.input});return this.hashCode(t)}hashCode(e){let t,s,r=0;if(0===e.length)return r;for(t=0;t<e.length;t++)s=e.charCodeAt(t),r=(r<<5)-r+s,r|=0;return r.toString()}applyFunc(e,t){return new Promise(((s,r)=>{try{s(e.apply(null,t))}catch(e){r(e)}}))}}const memoize=Memoize;class Distribute{constructor(e){this.hamsters=e,this.localConnection=null,this.remoteConnections=new e.observable({}),this.clientInfo=new e.observable({}),this.sendChannels=new e.observable({}),this.pcConstraint=null,this.ws=null,this.clientId=null,this.pendingPromises=new Map,this.pendingTasks=new e.observable({}),this.pendingTransfers=new e.observable({}),this.awaitingTransfers=new e.observable({}),this.lastRequestedTransfers=new e.observable({}),this.pendingOutputs=new e.observable({}),this.returnDistributedOutput=this.sendDataResponse.bind(this),this.establishConnection=this.initWebSocket.bind(this),this.lastHeartbeat={},this.heartBeatInterval=3e4,this.deletedPromises=[],this.heartBeatTimeout={},this.messageCounter=0,this.generatedMessageIds=[],this.messageToResponseMap=new Map,this.promiseTimeoutDuration=6e4,this.startPromiseCleanupInterval()}initWebSocket(){this.ws=new WebSocket(`${this.hamsters.habitat.relay}`),this.ws.onopen=()=>{console.info(`Hamsters.js ${this.hamsters.version} connection established`),this.ws.send(JSON.stringify({type:"register",logicalCores:this.hamsters.maxThreads})),this.sendHeartBeat(this.heartBeatInterval)},this.ws.onmessage=e=>{const t=JSON.parse(e.data);this.handleWebSocketMessage(t)},this.ws.onerror=e=>{this.hamsters.habitat.debug&&console.error(`Hamsters.js ${this.hamsters.version} connection error:`,e)},this.ws.onclose=()=>{this.hamsters.habitat.debug&&console.info(`Hamsters.js ${this.hamsters.version} connection closed. Reconnecting...`),this.establishConnection()}}handleWebSocketMessage(e){const t={register:this.handleClientReconnect.bind(this),"update-client-list":this.updateClientList.bind(this),offer:this.handleOffer.bind(this),answer:this.handleAnswer.bind(this),candidate:this.handleCandidate.bind(this)}[e.type];t?t(e):this.hamsters.habitat.debug&&console.info(`Hamsters.js ${this.hamsters.version} unknown message type: ${e.type}`)}sendHeartBeat(e){this.heartBeatTimeout=setInterval((()=>{this.ws.send(JSON.stringify({type:"heartbeat"})),this.lastHeartbeat=Date.now()}),e)}updateClientList(e){const t=e.clients,s=new Set(t.map((e=>e.id)));t.forEach((e=>{e.id===this.clientId||this.remoteConnections.get(e.id)||this.createConnection(e.id)}));const r=this.remoteConnections.getData();Object.keys(r).forEach((e=>{s.has(e)||this.handleClientDisconnect(e)}))}handleClientDisconnect(e){this.remoteConnections.get(e)&&(this.remoteConnections.get(e).close(),this.remoteConnections.delete(e,"peer")),this.sendChannels.get(e)&&(this.sendChannels.get(e).close(),this.sendChannels.delete(e,"channel")),this.clientInfo.delete(e)}handleClientReconnect(e){const t=e.id;this.clientId!==t?(this.handleClientDisconnect(t),this.clientId=t):this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} reconnected with same ID`)}createConnection(e){if(e===this.clientId||this.remoteConnections.get(e))return;const t=new RTCPeerConnection({iceServers:[{urls:"stun:stun.l.google.com:19302"}]},this.pcConstraint);t.onicecandidate=t=>{t.candidate&&this.ws.send(JSON.stringify({type:"candidate",target:e,from:this.clientId,logicalCores:this.hamsters.maxThreads,userAgent:navigator.userAgent,candidate:t.candidate}))},t.ondatachannel=t=>{this.dataChannelCallback(t,e)},this.findOrCreateChannel(e,t),this.remoteConnections.set(e,t),t.createOffer().then((s=>{t.setLocalDescription(s),this.ws.send(JSON.stringify({type:"offer",target:e,offer:s}))})).catch(this.onCreateSessionDescriptionError.bind(this))}handleOffer(e){const t=e.from;if(console.log("WE HAVE A OFFER ",e),!this.remoteConnections.get(t)){const s=new RTCPeerConnection({iceServers:[{urls:"stun:stun.l.google.com:19302"}]},this.pcConstraint);s.onicecandidate=e=>{e.candidate&&this.ws.send(JSON.stringify({type:"candidate",target:t,logicalCores:this.hamsters.maxThreads,userAgent:navigator.userAgent,candidate:e.candidate}))},s.ondatachannel=e=>{this.dataChannelCallback(e,t)},s.setRemoteDescription(new RTCSessionDescription(e.offer)).then((()=>s.createAnswer())).then((e=>(this.ws.send(JSON.stringify({type:"answer",target:t,logicalCores:this.hamsters.maxThreads,userAgent:navigator.userAgent,answer:e})),s.setLocalDescription(e)))).catch(this.onCreateSessionDescriptionError.bind(this)),this.remoteConnections.set(t,s,"peer"),this.findOrCreateChannel(t,s)}}findOrCreateChannel(e,t){let s=this.sendChannels.get(e);if(!s){const r={ordered:!0,maxRetransmits:3,id:Math.floor(65536*Math.random())};s=t.createDataChannel("hamstersjs",r),s.onopen=()=>{this.onSendChannelStateChange(e)},s.onclose=()=>{this.onSendChannelStateChange(e)},s.onmessage=t=>{this.onReceiveMessageCallback(e,t.data)},this.sendChannels.set(e,s,"channel")}return s}dataChannelCallback(e,t){const s=e.channel,r=t;s.onmessage=e=>{this.onReceiveMessageCallback(r,e.data)},this.sendChannels.set(r,s)}storeClientConnectionInfo(e){const t={logicalCores:e.logicalCores,userAgent:e.userAgent};this.clientInfo.set(e.from,t)}handleAnswer(e){this.storeClientConnectionInfo(e);const t=this.remoteConnections.get(e.from);t.setRemoteDescription(new RTCSessionDescription(e.answer)),this.remoteConnections.set(e.from,t)}handleCandidate(e){let t=this.remoteConnections.get(e.from);t||(this.storeClientConnectionInfo(e),t=this.remoteConnections.get(e.from)),t.addIceCandidate(new RTCIceCandidate(e.candidate)).catch(this.onAddIceCandidateError.bind(this)),this.remoteConnections.set(e.from,t)}distributeTask(e,t,s){const r=e.input.client||this.getDistributedClient();if(!r)return this.hamsters.habitat.debug&&console.error(`Hamsters.js ${this.hamsters.version} no target client found.`),void s("No target client found.");const a=this.generateUniqueId(),n=this.hamsters.data.getTransferList(e),i={hamsterFood:n.hamsterFood,task:n.task,messageId:a,type:"task-request"};this.pendingPromises.has(r)||this.pendingPromises.set(r,new Map),this.pendingPromises.get(r).set(a,{resolve:t,reject:s,state:"pending"}),n.transferCount>0&&this.pendingTransfers.set(a,n.transferList),this.sendData({targetClient:r,data:i})}getDistributedClient(){const e=Object.keys(this.sendChannels.getData());if(0===e.length)return this.hamsters.habitat.debug&&console.warn(`Hamsters.js ${this.hamsters.version} no send channels available.`),null;let t=1/0,s=null;return e.forEach((e=>{const r=this.sendChannels.get(e),a=this.clientInfo.get(e);"open"===r.readyState&&a&&a.latency<t&&(t=a.latency,s=e)})),s}initializeDistributedTask(e,t,s){const r=Object.keys(t.hamsterFood).filter((e=>"Awaiting Transfer"===t.hamsterFood[e])).reduce(((e,t)=>(e[t]="Awaiting Transfer",e)),{});if(Object.keys(r).length>0){let t=this.awaitingTransfers.get(e);t||(t=[]),t.push({messageId:s,transferList:r}),this.awaitingTransfers.set(e,t),this.requestNextTransfer(e,s)}else this.runDistributedTask(t,e)}requestNextTransfer(e,t){const s=this.lastRequestedTransfers.get(e);let r=null;if(s&&(r=s.find((e=>e.messageId===t)),r))return void console.info("We already requested this transfer for this task");const a=this.awaitingTransfers.get(e);if(a){const s=a.find((e=>e.messageId===t));s&&this.requestTransferFromList(s,t,e)}}requestTransferFromList(e,t,s){const r=Object.keys(e.transferList);if(r.length>0){const a=r.find((t=>"Awaiting Transfer"===e.transferList[t]));a&&(this.updateTransferStatus(s,t,a,"Requested Transfer"),this.requestDataTransfer(a,t,s))}}updateTransferStatus(e,t,s,r){const a=this.awaitingTransfers.get(e);if(!a)return void console.error(`Hamsters.js ${this.hamsters.version} no awaiting transfers found for ${e}`);const n=a.find((e=>e.messageId===t));n?(n.transferList[s]=r,this.awaitingTransfers.set(e,a)):console.error(`Hamsters.js ${this.hamsters.version} no awaiting transfer found for messageId ${t}`)}handleTransferResponse(e,t){let s=this.lastRequestedTransfers.get(e);if(!s||0===s.length)return void console.error(`Hamsters.js ${this.hamsters.version} received transfer response but no transfer was requested for ${e}`);const r=s[0],a=r.key,n=r.messageId||null,i=r.responseId||null;if(i){const s=this.pendingPromises.get(e);if(s){for(const[r,n]of s)if(n.responseId===i){const i=this.convertFromArrayBuffer(t,a);n.resolve(i),s.delete(r),0===s.size&&this.pendingPromises.delete(e);break}}else console.warn(`Hamsters.js ${this.hamsters.version} no pending promises found for ${e}`)}else{const s=this.pendingTasks.get(e);if(s){const r=s.findIndex((e=>e.messageId===n));if(r>-1){const i=s[r];i.hamsterFood[a]=this.convertFromArrayBuffer(t,a),Object.values(i.hamsterFood).some((e=>"Awaiting Transfer"===e))?this.requestNextTransfer(e,n):(s.splice(r,1),0===s.length?this.pendingTasks.delete(e):this.pendingTasks.set(e,s),this.runDistributedTask(i,e))}else console.warn(`Hamsters.js ${this.hamsters.version} no pending task found for targetClient: ${e} and messageId: ${n}`)}else console.warn(`Hamsters.js ${this.hamsters.version} no pending task found for targetClient: ${e} and messageId: ${n}`)}s=s.slice(1),0===s.length?this.lastRequestedTransfers.delete(e):this.lastRequestedTransfers.set(e,s),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} processed transfer response for ${a} from ${e}`)}measureLatency(e){const t=performance.now();this.sendPing(e,t)}sendPing(e,t){const s=this.sendChannels.get(e);s&&"open"===s.readyState&&s.send(JSON.stringify({type:"ping",startTime:t}))}handlePing(e,t){const s=this.sendChannels.get(e);s&&"open"===s.readyState&&(s.send(JSON.stringify({type:"pong",startTime:t})),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} sent pong to ${e}`))}handlePong(e,t){const s=performance.now()-t,r=this.clientInfo.get(e)||{};r.latency=s,this.clientInfo.set(e,r),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} received pong from ${e} with latency: ${s.toFixed(2)}ms`)}runDistributedTask(e,t){let s=e.task;s.targetClient=t,s.messageId=e.messageId,s.input=e.hamsterFood,s.type="task-response",console.log("RUNNING DISTRIBUTED TASK"),this.hamsters.scheduleTask(s,this.returnDistributedOutput,this.returnDistributedOutput)}sendDataResponse(e){const{targetClient:t,messageId:s,output:r}=e,a=this.generateUniqueId();this.initializeOutputTransfer(t,r,s,a)}initializeOutputTransfer(e,t,s,r){this.pendingOutputs.set(r,{targetClient:e,output:t,messageId:s});const a={type:"task-response",messageId:s,responseId:r,awaitingTransfers:!0};this.sendData({targetClient:e,data:a}),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} initialized output transfer for ${e} (responseId: ${r})`)}handleOutputTransferRequest(e,t){const{responseId:s}=t,r=this.pendingOutputs.get(s);if(r&&r.targetClient===e){const t=this.getArrayBuffer(r.output);this.sendBlobData({targetClient:e,data:t,dataType:"arrayBuffer"}),this.pendingOutputs.delete(s),this.messageToResponseMap.delete(r.messageId),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} sent output transfer for ${e} (responseId: ${s})`)}else console.error(`Hamsters.js ${this.hamsters.version} received unexpected output transfer request for ${e}`)}getArrayBuffer(e){return ArrayBuffer.isView(e)?e.buffer:e instanceof ArrayBuffer?e:new Uint8Array(e).buffer}convertFromArrayBuffer(e,t){const s=new Uint8Array(e);if(this.hamsters.habitat.node){const e=new ArrayBuffer(s.byteLength),t=new Uint8Array(e);return t.set(s),t}return s}sendData(e){let{targetClient:t,data:s}=e;const r=this.sendChannels.get(t);r&&"open"===r.readyState?(r.send(JSON.stringify(s)),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} sent data to: ${t}`)):this.hamsters.habitat.debug&&console.error(`Hamsters.js ${this.hamsters.version} send channel is not open for targetClient: ${t}`)}sendBlobData(e){let{targetClient:t,data:s,dataType:r}=e;const a=this.sendChannels.get(t);a&&"open"===a.readyState?(a.send(s),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} sent blob data to: ${t}`)):this.hamsters.habitat.debug&&console.error(`Hamsters.js ${this.hamsters.version} send channel is not open for targetClient: ${t}`)}async blobToArrayBuffer(e){if("function"==typeof fetch){const t=new Response(e);return await t.arrayBuffer()}throw new Error("Fetch API is not supported in this environment.")}async onReceiveMessageCallback(e,t){if(t instanceof Blob&&(t=await this.blobToArrayBuffer(t)),t instanceof ArrayBuffer)this.handleTransferResponse(e,t);else if("string"==typeof t){let s;try{s=JSON.parse(t),this.handleIncomingMessage(e,s)}catch(e){console.error(`Hamsters.js ${this.hamsters.version} error parsing message:`,e)}}else console.log("Received unexpected data type:",e,t)}handleIncomingMessage(e,t){const s={"transfer-request":this.fulfillTransferRequest.bind(this),"task-request":this.handleTaskRequest.bind(this),"transfer-response":this.processTransferResponse.bind(this),"output-transfer-request":this.handleOutputTransferRequest.bind(this),"task-response":this.handleTaskResponse.bind(this),ping:(e,t)=>this.handlePing(e,t.startTime),pong:(e,t)=>this.handlePong(e,t.startTime)}[t.type];s?s(e,t):console.log(`Hamsters.js ${this.hamsters.version} unknown message received from: ${e}`)}handleTaskRequest(e,t){let s=this.pendingTasks.get(e);s||(s=[]),s.push(t),this.pendingTasks.set(e,s),Object.values(t.hamsterFood).some((e=>"Awaiting Transfer"===e))?this.initializeDistributedTask(e,t,t.messageId):this.runDistributedTask(t,e)}startPromiseCleanupInterval(){setInterval((()=>this.cleanupStalePendingPromises()),3e4)}cleanupStalePendingPromises(){const e=Date.now();for(const[t,s]of this.pendingPromises){for(const[t,r]of s)e-r.timestamp>this.promiseTimeoutDuration&&(r.reject(new Error("Task timed out")),s.delete(t));0===s.size&&this.pendingPromises.delete(t)}}handleTaskResponse(e,t){const{messageId:s,responseId:r,awaitingTransfers:a,output:n}=t,i=this.pendingPromises.get(e);if(i&&i.has(s)){const t=i.get(s);a&&r?(t.state="awaitingTransfer",t.responseId=r,this.requestOutputTransfer(e,r,s)):(t.resolve(n),i.delete(s),0===i.size&&this.pendingPromises.delete(e))}else console.warn(`Received a message from ${e} but no matching promise found with messageId ${s}`)}requestOutputTransfer(e,t,s){let r=this.lastRequestedTransfers.get(e);r||(r=[]);const a={type:"output-transfer-request",key:"output",responseId:t,messageId:s};r.push(a),this.lastRequestedTransfers.set(e,r),this.sendData({targetClient:e,data:a})}requestDataTransfer(e,t,s){let r=this.lastRequestedTransfers.get(s);r||(r=[]);const a={type:"transfer-request",key:e,messageId:t};r.push(a),this.lastRequestedTransfers.set(s,r),this.sendData({targetClient:s,data:a});const n=this.awaitingTransfers.get(s);n&&n.messageId===t&&(n.transfers[e]="Requested Transfer",this.awaitingTransfers.set(s,n)),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} requested transfer for ${e} from ${s} (messageId: ${t})`)}fulfillTransferRequest(e,t){const{key:s,messageId:r,responseId:a}=t,n=a||r,i=this.pendingTransfers.get(n);if(i&&i[s]){const t=i[s],o=this.getArrayBuffer(t);this.sendBlobData({targetClient:e,data:o,dataType:"arrayBuffer"}),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} sent transfer response for ${s} (${a?"output":"input"}) to ${e} (messageId: ${r})`),delete i[s],0===Object.keys(i).length&&this.pendingTransfers.delete(n)}else console.error(`No pending transfer found for ${s} (${a?"output":"input"}) for ${e} (messageId: ${r})`)}processTransferResponse(e,t){const{key:s,data:r,messageId:a,responseId:n}=t;if(n){const e=this.pendingPromises.get(a);e?(e.resolve(r),this.pendingPromises.delete(a)):console.warn(`Hamsters.js ${this.hamsters.version} no pending promise found for messageId: ${a}`)}else{const t=this.pendingTasks.get(e);if(t){const n=t.findIndex((e=>e.messageId===a));if(n>-1){const i=t[n];i.hamsterFood[s]=this.convertFromArrayBuffer(r),Object.values(i.hamsterFood).some((e=>"Awaiting Transfer"===e))?this.requestNextTransfer(e,a):(t.splice(n,1),0===t.length?this.pendingTasks.delete(e):this.pendingTasks.set(e,t),this.runDistributedTask(i,e))}else console.warn(`Hamsters.js ${this.hamsters.version} no pending task found for targetClient: ${e} and messageId: ${a}`)}else console.warn(`Hamsters.js ${this.hamsters.version} no pending task found for targetClient: ${e} and messageId: ${a}`)}const i=this.lastRequestedTransfers.get(e);i&&(i.shift(),0===i.length?this.lastRequestedTransfers.delete(e):this.lastRequestedTransfers.set(e,i)),this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} processed transfer response for ${s} from ${e}`)}onSendChannelStateChange(e){const t=this.sendChannels.get(e);t&&"open"===t.readyState&&this.measureLatency(e),t&&this.hamsters.habitat.debug&&console.log(`Hamsters.js ${this.hamsters.version} send channel state changed for ${e}: ${t.readyState}`)}generateUniqueId(){const e=Date.now().toString(36),t=Math.random().toString(36).substr(2,5);return this.messageCounter=(this.messageCounter+1)%1e6,`${e}-${t}-${this.messageCounter.toString(36).padStart(5,"0")}`}onCreateSessionDescriptionError(e){this.hamsters.habitat.debug&&console.error(`Hamsters.js ${this.hamsters.version} failed to create session description: ${e}`)}onAddIceCandidateError(e){this.hamsters.habitat.debug&&console.error(`Hamsters.js ${this.hamsters.version} failed to add ICE candidate: ${e}`)}}const distribute=Distribute;class Observable{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.data=Array.isArray(e)?[...e]:{...e},this.events={}}on(e,t){this.events[e]||(this.events[e]=[]),this.events[e].push(t)}emit(e){for(var t=arguments.length,s=new Array(t>1?t-1:0),r=1;r<t;r++)s[r-1]=arguments[r];this.events[e]&&this.events[e].forEach((e=>e(...s)))}emitEvents(e,t){"change"!==e&&this.emit(e,t),this.emit("change",t)}set(e,t){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"change";if(this.data[e],"string"==typeof e){const s=e.split(".");let r=this.data;for(let e=0;e<s.length-1;e++)r=r[s[e]];r[s[s.length-1]]=t}else"object"==typeof e&&(this.data[e]=t);return this.emitEvents(s,this.data),t}setAll(e){this.data=e}get(e){return this.data[e]}push(){this.data.push(...arguments),this.emitEvents("change",this.data)}pop(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"change";const t=this.data.pop();return this.emitEvents(e,this.data),t}shift(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"change",t=this.data.shift();return this.emitEvents(e,this.data),t}splice(e,t){for(var s=arguments.length,r=new Array(s>2?s-2:0),a=2;a<s;a++)r[a-2]=arguments[a];const n=this.data.splice(e,t,...r);return this.emitEvents("change",this.data),n}indexOf(e){return this.data.indexOf(e)}length(){return this.data.length}delete(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"change";Array.isArray(this.data)||(delete this.data[e],this.emitEvents(t,this.data))}getData(){return this.data}}const observable=Observable;class hamstersjs{constructor(){this.version="5.6.3",this.run=this.hamstersRun.bind(this),this.promise=this.hamstersPromise.bind(this),this.init=this.initializeLibrary.bind(this),this.data={},this.pool={},this.scaffold={},this.habitat={},this.memoize={}}initializeLibrary(e){const t=performance.now();this.observable=observable,this.data=new data(this),this.pool=new pool(this),this.scaffold={legacy:new legacy.A,regular:new regular.A,shared:new shared.A},this.habitat=new habitat(this),this.memoize=new memoize(this,100),this.distribute=new distribute(this),this.processStartOptions(e),this.habitat.legacy||!0!==this.habitat.persistence||this.pool.spawnHamsters(this.habitat.maxThreads),this.maxThreads=this.habitat.maxThreads,this.habitat.relay&&(console.info(`Hamsters.js ${this.version} establishing connection to relay`),this.distribute.establishConnection());const s=performance.now();console.info(`Hamsters.js ${this.version} initialized using up to ${this.habitat.maxThreads} threads in ${s-t}ms`)}processStartOptions(e){if(void 0!==e)for(const t of Object.keys(e))this.habitat.keys.includes(t.toLowerCase())?this.habitat[t]=e[t]:"scaffold"===t?this.scaffold.custom=e[t]:this[t]=e[t];let t=void 0!==e&&void 0!==e.legacy;t&&(t=e.legacy),"function"!=typeof this.habitat.Worker||t||(this.habitat.legacy=this.habitat.isIE)}scheduleTask(e,t,s){return e.input.memoize?this.memoize.memoize((()=>this.pool.scheduleTask(e,t,s)))(e).then(t).catch(s):this.pool.scheduleTask(e,t,s)}hamstersPromise(e,t){return new Promise(((s,r)=>{this.scheduleTask(new task(this,e,t),s,r)}))}hamstersRun(e,t,s,r){this.scheduleTask(new task(this,e,t),s,r)}}const hamsters=new hamstersjs;return __webpack_exports__=__webpack_exports__.default,__webpack_exports__})()));
//# sourceMappingURL=hamsters.web.min.js.map