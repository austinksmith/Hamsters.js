var hamsters =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* jshint esversion: 6, curly: true, eqeqeq: true, forin: true */
	
	/***********************************************************************************
	* Title: Hamsters.js                                                               *
	* Description: 100% Vanilla Javascript Multithreading & Parallel Execution Library *
	* Author: Austin K. Smith                                                          *
	* Contact: austin@asmithdev.com                                                    *  
	* Copyright: 2015 Austin K. Smith - austin@asmithdev.com                           * 
	* License: Artistic License 2.0                                                    *
	***********************************************************************************/
	
	var _habitat = __webpack_require__(2);
	
	var _habitat2 = _interopRequireDefault(_habitat);
	
	var _pool = __webpack_require__(5);
	
	var _pool2 = _interopRequireDefault(_pool);
	
	var _data = __webpack_require__(6);
	
	var _data2 = _interopRequireDefault(_data);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var hamstersjs = function () {
	
	  /**
	  * @constructor
	  * @function constructor - Sets properties for this class
	  */
	  function hamstersjs() {
	    'use strict';
	
	    _classCallCheck(this, hamstersjs);
	
	    this.version = '5.4.3';
	    this.habitat = _habitat2.default;
	    this.data = _data2.default;
	    this.pool = _pool2.default;
	    this.run = this.hamstersRun.bind(this);
	    this.promise = this.hamstersPromise.bind(this);
	    this.init = this.inititializeLibrary.bind(this);
	  }
	
	  /**
	  * @function initializeLibrary - Prepares & initializes Hamsters.js library
	  * @param {object} startOptions - Provided library functionality options
	  */
	
	
	  _createClass(hamstersjs, [{
	    key: 'inititializeLibrary',
	    value: function inititializeLibrary(startOptions) {
	      this.processStartOptions(startOptions);
	      if (!this.habitat.legacy && this.habitat.persistence === true) {
	        _pool2.default.spawnHamsters(this.habitat.maxThreads);
	      }
	      this.maxThreads = this.habitat.maxThreads;
	      console.info('Hamsters.js ' + this.version + ' initialized using up to ' + this.habitat.maxThreads + ' threads');
	    }
	
	    /**
	    * @function processStartOptions - Adjusts library functionality based on provided options
	    * @param {object} startOptions - Provided library functionality options
	    */
	
	  }, {
	    key: 'processStartOptions',
	    value: function processStartOptions(startOptions) {
	      if (typeof startOptions !== 'undefined') {
	        var _iteratorNormalCompletion = true;
	        var _didIteratorError = false;
	        var _iteratorError = undefined;
	
	        try {
	          for (var _iterator = Object.keys(startOptions)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var key = _step.value;
	
	            if (this.habitat.keys.indexOf(key.toLowerCase()) !== -1) {
	              this.habitat[key] = startOptions[key];
	            } else {
	              this[key] = startOptions[key];
	            }
	          }
	        } catch (err) {
	          _didIteratorError = true;
	          _iteratorError = err;
	        } finally {
	          try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	              _iterator.return();
	            }
	          } finally {
	            if (_didIteratorError) {
	              throw _iteratorError;
	            }
	          }
	        }
	      }
	      // Ensure legacy mode is disabled when we pass a third party worker library
	      var forceLegacyMode = typeof startOptions !== 'undefined' && typeof startOptions.legacy !== 'undefined';
	      if (forceLegacyMode) {
	        forceLegacyMode = startOptions.legacy;
	      }
	      if (typeof this.habitat.Worker === 'function' && !forceLegacyMode) {
	        this.habitat.legacy = this.habitat.isIE;
	      }
	    }
	
	    /**
	    * @constructor
	    * @function hamstersTask - Constructs a new task object from provided arguments
	    * @param {object} params - Provided library execution options
	    * @param {function} functionToRun - Function to execute
	    * @return {object} new Hamsters.js task
	    */
	
	  }, {
	    key: 'hamstersTask',
	    value: function hamstersTask(params, functionToRun) {
	      var task = {
	        input: params,
	        scheduler: {
	          count: 0,
	          threads: params.threads ? params.threads : 1,
	          workers: []
	        }
	      };
	      if (this.habitat.legacy) {
	        task.scheduler.threads = 1;
	        if (!this.habitat.node && !this.habitat.isIE) {
	          params.hamstersJob = functionToRun;
	        }
	      } else {
	        params.hamstersJob = this.data.prepareFunction(functionToRun);
	        task.scheduler.indexes = params.indexes ? params.indexes : this.data.getSubArrayIndexes(params.array, task.scheduler.threads);
	      }
	      if (this.habitat.debug) {
	        task.scheduler.metrics = {
	          created_at: Date.now(),
	          started_at: null,
	          completed_at: null,
	          threads: []
	        };
	      }
	      return task;
	    }
	
	    /**
	    * @async
	    * @function hamstersPromise - Schedules new function to be processed by library
	    * @param {object} task - Provided library execution options
	    * @param {function} resolve - Parent function promise resolve method
	    * @param {function} reject- Parent function promise reject method
	    * @return {object} Promise object on completion
	    */
	
	  }, {
	    key: 'scheduleTask',
	    value: function scheduleTask(task, resolve, reject) {
	      return this.pool.scheduleTask(task).then(function (results) {
	        resolve(results);
	      }).catch(function (error) {
	        // console.error("Hamsters.js error encountered: ", error);
	        reject(error);
	      });
	    }
	
	    /**
	    * @async
	    * @function hamstersPromise - Calls library functionality using async promises
	    * @param {object} params - Provided library execution options
	    * @param {function} functionToRun - Function to execute
	    * @return {array} Results from functionToRun
	    */
	
	  }, {
	    key: 'hamstersPromise',
	    value: function hamstersPromise(params, functionToRun) {
	      var _this = this;
	
	      return new Promise(function (resolve, reject) {
	        _this.scheduleTask(_this.hamstersTask(params, functionToRun), resolve, reject);
	      });
	    }
	
	    /**unction} functionToRun - Function to execute
	    * @param {function} onSuccess - Function to call upon successful execution
	    * @param {f
	    * @async
	    * @function hamstersRun - Calls library functionality using async callbacks
	    * @param {object} params - Provided library execution options
	    * @param {function} onError - Function to call upon execution failure
	    * @return {array} Results from functionToRun.
	    */
	
	  }, {
	    key: 'hamstersRun',
	    value: function hamstersRun(params, functionToRun, onSuccess, onError) {
	      this.scheduleTask(this.hamstersTask(params, functionToRun), onSuccess, onError);
	    }
	  }]);
	
	  return hamstersjs;
	}();
	
	var hamsters = new hamstersjs();
	
	if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
	  module.exports = hamsters;
	}

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* jshint esversion: 6, curly: true, eqeqeq: true, forin: true */
	
	/***********************************************************************************
	* Title: Hamsters.js                                                               *
	* Description: 100% Vanilla Javascript Multithreading & Parallel Execution Library *
	* Author: Austin K. Smith                                                          *
	* Contact: austin@asmithdev.com                                                    *  
	* Copyright: 2015 Austin K. Smith - austin@asmithdev.com                           * 
	* License: Artistic License 2.0                                                    *
	***********************************************************************************/
	
	var _wheel = __webpack_require__(4);
	
	var _wheel2 = _interopRequireDefault(_wheel);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var habitat = function () {
	
	  /**
	  * @constructor
	  * @function constructor - Sets properties for this class
	  */
	  function habitat() {
	    'use strict';
	
	    _classCallCheck(this, habitat);
	
	    this.debug = false;
	    this.importScripts = null;
	    this.memoize = false;
	    this.persistence = true;
	    this.browser = this.isBrowser();
	    this.webWorker = this.isWebWorker();
	    this.node = this.isNode();
	    this.reactNative = this.isReactNative();
	    this.shell = this.isShell();
	    this.transferable = this.supportstransferableObjects();
	    this.atomics = this.supportsAtomicOperations();
	    this.proxies = this.supportsProxies();
	    this.isIE = this.isInternetExplorer();
	    this.hamsterWheel = this.selectHamsterWheel();
	    this.sharedWorker = this.locateSharedWorkerObject();
	    this.locateBlobBuilder = this.findAvailableBlobBuilder();
	    this.legacy = this.isLegacyEnvironment();
	    this.legacyWheel = _wheel2.default.legacy;
	    this.Worker = this.locateWorkerObject();
	    this.maxThreads = this.determineGlobalThreads();
	    this.keys = this.getHabitatKeys();
	  }
	
	  /**
	  * @function determineGlobalThreads - Determines max number of threads to use
	  */
	
	
	  _createClass(habitat, [{
	    key: 'determineGlobalThreads',
	    value: function determineGlobalThreads() {
	      var max = 4;
	      if (this.browser && typeof navigator.hardwareConcurrency !== "undefined") {
	        max = navigator.hardwareConcurrency;
	        if (this.isFirefox()) {
	          max = max > 20 ? 20 : max;
	        }
	      }
	      if (this.node && typeof os !== 'undefined') {
	        max = os.cpus().length;
	      }
	      return max;
	    }
	
	    /**
	    * @function isFireox - Detect firefox browser
	    */
	
	  }, {
	    key: 'isFirefox',
	    value: function isFirefox() {
	      if (typeof navigator !== "undefined" && typeof navigator.userAgent !== "undefined") {
	        return navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;
	      }
	      return false;
	    }
	
	    /**
	    * @function locateWorkerObject - Attempts to find a global Worker object
	    */
	
	  }, {
	    key: 'locateWorkerObject',
	    value: function locateWorkerObject() {
	      return typeof Worker !== 'undefined' ? Worker : false;
	    }
	
	    /**
	    * @function locateSharedWorkerObject - Attempts to find a global SharedWorker object
	    */
	
	  }, {
	    key: 'locateSharedWorkerObject',
	    value: function locateSharedWorkerObject() {
	      return typeof SharedWorker !== 'undefined' ? SharedWorker : false;
	    }
	
	    /**
	    * @function isBrowser - Detects if execution environment is a browser
	    */
	
	  }, {
	    key: 'isBrowser',
	    value: function isBrowser() {
	      return (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === "object";
	    }
	
	    /**
	    * @function isInternetExplorer - Detects if execution environment is internet explorer
	    */
	
	  }, {
	    key: 'isInternetExplorer',
	    value: function isInternetExplorer() {
	      if (typeof navigator !== "undefined" && typeof navigator.userAgent !== "undefined") {
	        return navigator.userAgent.indexOf("MSIE ") !== -1 || navigator.userAgent.indexOf("Trident/") !== -1;
	      }
	      return false;
	    }
	
	    /**
	    * @function isNode - Detects if execution environment is node.js
	    */
	
	  }, {
	    key: 'isNode',
	    value: function isNode() {
	      return (typeof process === 'undefined' ? 'undefined' : _typeof(process)) === "object" && "function" === "function" && !this.isWebWorker() && !this.browser;
	    }
	
	    /**
	    * @function isWebWorker - Detects if execution environment is a webworker
	    */
	
	  }, {
	    key: 'isWebWorker',
	    value: function isWebWorker() {
	      return typeof importScripts === "function" && !this.isReactNative();
	    }
	
	    /**
	    * @function isReactNative - Detects if execution environment is reactNative
	    */
	
	  }, {
	    key: 'isReactNative',
	    value: function isReactNative() {
	      return typeof navigator !== "undefined" && typeof navigator.product !== "undefined" && navigator.product === "ReactNative";
	    }
	
	    /**
	    * @function isShell - Detects if execution environment is a shell
	    */
	
	  }, {
	    key: 'isShell',
	    value: function isShell() {
	      return typeof navigator === "undefined" && !this.isNode() && !this.isWebWorker() && !this.isReactNative();
	    }
	
	    /**
	    * @function isLegacyEnvironment - Detects if execution environment is a legacy environment
	    */
	
	  }, {
	    key: 'isLegacyEnvironment',
	    value: function isLegacyEnvironment() {
	      var isLegacy = !!!this.Worker;
	      // Detect sharedWorker support for use within webworkers
	      if (this.isWebWorker() && typeof this.SharedWorker !== 'undefined') {
	        isLegacy = !this.supportsSharedWorkers();
	      }
	      return isLegacy;
	    }
	  }, {
	    key: 'supportsSharedWorkers',
	    value: function supportsSharedWorkers() {
	      var supports = false;
	      try {
	        var workerBlob = this.generateWorkerBlob(this.hamsterWheel);
	        var SharedHamster = new this.SharedWorker(workerBlob, 'SharedHamsterWheel');
	        supports = true;
	      } catch (e) {
	        supports = false;
	      }
	      return supports;
	    }
	
	    /**
	    * @function createDataBlob - Attempts to locate data blob builder, vender prefixes galore
	    */
	
	  }, {
	    key: 'findAvailableBlobBuilder',
	    value: function findAvailableBlobBuilder() {
	      if (typeof BlobBuilder !== 'undefined') {
	        return BlobBuilder;
	      }
	      if (typeof WebKitBlobBuilder !== 'undefined') {
	        return WebKitBlobBuilder;
	      }
	      if (typeof MozBlobBuilder !== 'undefined') {
	        return MozBlobBuilder;
	      }
	      if (typeof MSBlobBuilder !== 'undefined') {
	        return MSBlobBuilder;
	      }
	      return 'Environment does not support data blobs!';
	    }
	
	    /**
	    * @function createDataBlob - Creates new data blob from textContent
	    * @param {string} textContent - Provided text content for blob
	    */
	
	  }, {
	    key: 'createDataBlob',
	    value: function createDataBlob(textContent) {
	      if (typeof Blob === 'undefined') {
	        var BlobMaker = this.locateBlobBuilder();
	        var blob = new BlobMaker();
	        blob.append([textContent], {
	          type: 'application/javascript'
	        });
	        return blob.getBlob();
	      }
	      return new Blob([textContent], {
	        type: 'application/javascript'
	      });
	    }
	
	    /**
	    * @function generateWorkerBlob - Creates blob uri for flexible scaffold loading
	    * @param {function} workerLogic - Scaffold to use within worker thread
	    */
	
	  }, {
	    key: 'generateWorkerBlob',
	    value: function generateWorkerBlob(workerLogic) {
	      return URL.createObjectURL(this.createDataBlob('(' + String(workerLogic) + ')();'));
	    }
	
	    /**
	    * @function supportstransferableObjects - Detects if execution environment supports typed arrays
	    */
	
	  }, {
	    key: 'supportstransferableObjects',
	    value: function supportstransferableObjects() {
	      return typeof Uint8Array !== 'undefined';
	    }
	
	    /**
	    * @function supportsAtomicOperations - Detects if execution environment supports shared array buffers
	    */
	
	  }, {
	    key: 'supportsAtomicOperations',
	    value: function supportsAtomicOperations() {
	      return typeof SharedArrayBuffer !== 'undefined';
	    }
	
	    /**
	    * @function supportsProxies - Detects if execution environment supports proxy objects
	    */
	
	  }, {
	    key: 'supportsProxies',
	    value: function supportsProxies() {
	      return typeof Proxy !== 'undefined';
	    }
	
	    /**
	    * @function scheduleTask - Determines which scaffold to use for proper execution for various environments
	    */
	
	  }, {
	    key: 'selectHamsterWheel',
	    value: function selectHamsterWheel() {
	      if (this.isIE) {
	        return _wheel2.default.legacy;
	      }
	      if (this.reactNative) {
	        return 'reactNativeHamster.js';
	      }
	      if (this.node) {
	        return './node_modules/hamsters.js/build/common/node.js';
	      }
	      return this.generateWorkerBlob(_wheel2.default.regular);
	    }
	  }, {
	    key: 'getHabitatKeys',
	    value: function getHabitatKeys() {
	      return ['worker', 'sharedworker', 'legacy', 'proxies', 'reactnative', 'atomics', 'transferable', 'browser', 'shell', 'node', 'debug', 'persistence', 'importscripts', 'maxthreads', 'parentport', 'webworker'];
	    }
	  }]);
	
	  return habitat;
	}();
	
	var hamstersHabitat = new habitat();
	
	if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
	  module.exports = hamstersHabitat;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),
/* 3 */
/***/ (function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;
	
	process.listeners = function (name) { return [] }
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ }),
/* 4 */
/***/ (function(module, exports) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/* jshint esversion: 6, curly: true, eqeqeq: true, forin: true */
	
	/***********************************************************************************
	* Title: Hamsters.js                                                               *
	* Description: 100% Vanilla Javascript Multithreading & Parallel Execution Library *
	* Author: Austin K. Smith                                                          *
	* Contact: austin@asmithdev.com                                                    *  
	* Copyright: 2015 Austin K. Smith - austin@asmithdev.com                           * 
	* License: Artistic License 2.0                                                    *
	***********************************************************************************/
	
	var wheel = function () {
	
	  /**
	  * @constructor
	  * @function constructor - Sets properties for this class
	  */
	  function wheel() {
	    'use strict';
	
	    _classCallCheck(this, wheel);
	
	    this.worker = this.workerScaffold;
	    this.regular = this.regularScaffold;
	    this.legacy = this.legacyScaffold;
	  }
	
	  /**
	  * @function workerScaffold - Provides worker body for library functionality when used within a worker [threads inside threads]
	  */
	
	
	  _createClass(wheel, [{
	    key: 'workerScaffold',
	    value: function workerScaffold() {
	      self.params = {};
	      self.rtn = {};
	
	      addEventListener('connect', function (incomingConnection) {
	        var port = incomingConnection.ports[0];
	        port.start();
	        port.addEventListener('message', function (incomingMessage) {
	          params = incomingMessage.data;
	          rtn = {
	            data: [],
	            dataType: params.dataType
	          };
	          eval("(" + params.hamstersJob + ")")();
	          port.postMessage(rtn);
	        }, false);
	      }, false);
	    }
	
	    /**
	    * @function workerScaffold - Provides worker body for library functionality
	    */
	
	  }, {
	    key: 'regularScaffold',
	    value: function regularScaffold() {
	      self.params = {};
	      self.rtn = {};
	
	      self.onmessage = function (message) {
	        params = message.data;
	        rtn = {
	          data: [],
	          dataType: typeof params.dataType !== 'undefined' ? params.dataType : null
	        };
	        eval(params.hamstersJob);
	        if (rtn.dataType) {
	          rtn.data = typedArrayFromBuffer(rtn.dataType, rtn.data);
	        }
	        returnResponse(rtn);
	      };
	
	      function typedArrayFromBuffer(dataType, buffer) {
	        var types = {
	          'Uint32': Uint32Array,
	          'Uint16': Uint16Array,
	          'Uint8': Uint8Array,
	          'Uint8clamped': Uint8ClampedArray,
	          'Int32': Int32Array,
	          'Int16': Int16Array,
	          'Int8': Int8Array,
	          'Float32': Float32Array,
	          'Float64': Float64Array
	        };
	        if (!types[dataType]) {
	          return buffer;
	        }
	        return new types[dataType](buffer);
	      }
	
	      function returnResponse(rtn, buffers) {
	        if (typeof rtn.data.buffer !== 'undefined') {
	          postMessage(rtn, [rtn.data.buffer]);
	        } else {
	          postMessage(rtn);
	        }
	      }
	    }
	
	    /**
	    * @function legacyScaffold - Provides library functionality for legacy devices
	    */
	
	  }, {
	    key: 'legacyScaffold',
	    value: function legacyScaffold(hamstersHabitat, params, resolve, reject) {
	      var rtn = {
	        data: [],
	        dataType: typeof params.dataType !== "undefined" ? params.dataType : null
	      };
	      if (hamstersHabitat.reactNative) {
	        self.rtn = rtn;
	      }
	      if (hamstersHabitat.node || hamstersHabitat.isIE) {
	        eval(params.hamstersJob);
	      } else {
	        params.hamstersJob();
	      }
	      resolve(rtn.data);
	    }
	  }]);
	
	  return wheel;
	}();
	
	var hamstersWheel = new wheel();
	
	if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
	  module.exports = hamstersWheel;
	}

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* jshint esversion: 6, curly: true, eqeqeq: true, forin: true */
	
	/***********************************************************************************
	* Title: Hamsters.js                                                               *
	* Description: 100% Vanilla Javascript Multithreading & Parallel Execution Library *
	* Author: Austin K. Smith                                                          *
	* Contact: austin@asmithdev.com                                                    *  
	* Copyright: 2015 Austin K. Smith - austin@asmithdev.com                           * 
	* License: Artistic License 2.0                                                    *
	***********************************************************************************/
	
	var _data = __webpack_require__(6);
	
	var _data2 = _interopRequireDefault(_data);
	
	var _habitat = __webpack_require__(2);
	
	var _habitat2 = _interopRequireDefault(_habitat);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var pool = function () {
	
	  /**
	  * @constructor
	  * @function constructor - Sets properties for this class
	  */
	  function pool() {
	    'use strict';
	
	    _classCallCheck(this, pool);
	
	    this.threads = [];
	    this.running = [];
	    this.pending = [];
	    this.fetchHamster = this.getAvailableThread;
	  }
	
	  /**
	  * @function fetchHamster - Adds task to queue waiting for available thread
	  * @param {object} array - Provided data to execute logic on
	  * @param {object} task - Provided library functionality options for this task
	  * @param {boolean} persistence - Whether persistence mode is enabled or not
	  * @param {function} wheel - Results from select hamster wheel
	  * @param {function} resolve - onSuccess method
	  * @param {function} reject - onError method
	  */
	
	
	  _createClass(pool, [{
	    key: 'addWorkToPending',
	    value: function addWorkToPending(index, task, resolve, reject) {
	      if (_habitat2.default.debug) {
	        task.scheduler.metrics.threads[task.scheduler.count].enqueued_at = Date.now();
	      }
	      this.pending.push({
	        index: index,
	        count: task.scheduler.count,
	        task: task,
	        resolve: resolve,
	        reject: reject
	      });
	    }
	
	    /**
	    * @function processQueuedItem - Invokes processing of next item in queue
	    * @param {object} item - Task to process
	    */
	
	  }, {
	    key: 'processQueuedItem',
	    value: function processQueuedItem(hamster, item) {
	      if (_habitat2.default.debug) {
	        item.task.scheduler.metrics.threads[item.count].dequeued_at = Date.now();
	      }
	      return this.runTask(hamster, item.index, item.task, item.resolve, item.reject);
	    }
	
	    /**
	    * @function getAvailableThread- Keeps track of threads running, scoped globally and to task
	    * @param {number} threadId - Id of thread
	    * @param {boolean} persistence - Whether persistence mode is enabled or not
	    * @param {function} wheel - Results from select hamster wheel
	    */
	
	  }, {
	    key: 'getAvailableThread',
	    value: function getAvailableThread(threadId) {
	      if (_habitat2.default.persistence) {
	        return this.threads[threadId];
	      }
	      return this.spawnHamster();
	    }
	
	    /**
	    * @function keepTrackOfThread - Keeps track of threads running, scoped globally and to task
	    * @param {object} task - Provided library functionality options for this task
	    * @param {number} id - Id of thread to track
	    */
	
	  }, {
	    key: 'keepTrackOfThread',
	    value: function keepTrackOfThread(task, id) {
	      if (_habitat2.default.debug) {
	        task.scheduler.metrics.threads[id].started_at = Date.now();
	      }
	      task.scheduler.workers.push(id); //Keep track of threads scoped to current task
	      this.running.push(id); //Keep track of all currently running threads
	    }
	
	    /**
	    * @function spawnHamsters - Spawns multiple new threads for execution
	    * @param {function} wheel - Results from select hamster wheel
	    * @param {number} maxThreds - Max number of threads for this client
	    */
	
	  }, {
	    key: 'spawnHamsters',
	    value: function spawnHamsters(maxThreads) {
	      for (maxThreads; maxThreads > 0; maxThreads--) {
	        this.threads.push(this.spawnHamster());
	      }
	    }
	
	    /**
	    * @function spawnHamster - Spawns a new thread for execution
	    * @return {object} WebWorker - New WebWorker thread using selected scaffold
	    */
	
	  }, {
	    key: 'spawnHamster',
	    value: function spawnHamster() {
	      if (_habitat2.default.webWorker) {
	        return new _habitat2.default.SharedWorker(_habitat2.default.hamsterWheel, 'SharedHamsterWheel');
	      }
	      if (_habitat2.default.node && typeof _habitat2.default.parentPort !== 'undefined') {
	        return new _habitat2.default.Worker(_habitat2.default.hamsterWheel);
	      }
	      return new _habitat2.default.Worker(_habitat2.default.hamsterWheel);
	    }
	
	    /**
	    * @function prepareMeal - Prepares message to send to a thread and invoke execution
	    * @param {object} threadArray - Provided data to execute logic on
	    * @param {object} task - Provided library functionality options for this task
	    * @return {object} hamsterFood - Prepared message to send to a thread
	    */
	
	  }, {
	    key: 'prepareMeal',
	    value: function prepareMeal(index, task) {
	      var hamsterFood = {};
	      hamsterFood.array = _data2.default.getSubArrayFromIndex(index, task);
	      for (var key in task.input) {
	        if (task.input.hasOwnProperty(key) && ['array', 'threads'].indexOf(key) === -1) {
	          hamsterFood[key] = task.input[key];
	        }
	      }
	      return hamsterFood;
	    }
	
	    /**
	    * @function hamsterWheel - Runs function using thread
	    * @param {object} array - Provided data to execute logic on
	    * @param {object} task - Provided library functionality options for this task
	    * @param {boolean} persistence - Whether persistence mode is enabled or not
	    * @param {function} wheel - Results from select hamster wheel
	    * @param {function} resolve - onSuccess method
	    * @param {function} reject - onError method
	    */
	
	  }, {
	    key: 'runTask',
	    value: function runTask(hamster, index, task, resolve, reject) {
	      var threadId = this.running.length;
	      var hamsterFood = this.prepareMeal(index, task);
	      this.keepTrackOfThread(task, threadId);
	      if (_habitat2.default.legacy) {
	        _habitat2.default.legacyWheel(_habitat2.default, hamsterFood, resolve, reject);
	      } else {
	        this.trainHamster(this, _habitat2.default, index, task, threadId, hamster, resolve, reject);
	        _data2.default.feedHamster(_habitat2.default, hamster, hamsterFood);
	      }
	      task.scheduler.count += 1;
	    }
	
	    /**
	    * @function hamsterWheel - Runs or queues function using threads
	    * @param {object} array - Provided library functionality options for this task
	    * @param {object} task - Provided library functionality options for this task
	    * @param {boolean} persistence - Whether persistence mode is enabled or not
	    * @param {function} wheel - Results from select hamster wheel
	    * @param {function} resolve - onSuccess method
	    * @param {function} reject - onError method
	    */
	
	  }, {
	    key: 'hamsterWheel',
	    value: function hamsterWheel(index, task, resolve, reject) {
	      if (_habitat2.default.maxThreads <= this.running.length) {
	        return this.addWorkToPending(index, task, resolve, reject);
	      }
	      var hamster = this.fetchHamster(this.running.length);
	      return this.runTask(hamster, index, task, resolve, reject);
	    }
	
	    /**
	    * @function returnOutputAndRemoveTask - gathers thread outputs into final result
	    * @param {object} task - Provided library functionality options for this task
	    * @param {function} resolve - onSuccess method
	    */
	
	  }, {
	    key: 'returnOutputAndRemoveTask',
	    value: function returnOutputAndRemoveTask(task, resolve) {
	      if (task.sort) {
	        resolve(_data2.default.sortOutput(task.input.array, task.sort));
	      } else {
	        resolve(task.input.array);
	      }
	      if (_habitat2.default.debug) {
	        task.scheduler.metrics.completed_at = Date.now();
	        console.info("Hamsters.js Task Completed: ", task);
	      }
	    }
	  }, {
	    key: 'removeFromRunning',
	    value: function removeFromRunning(task, threadId) {
	      this.running.splice(this.running.indexOf(threadId), 1); //Remove thread from running pool
	      task.scheduler.workers.splice(task.scheduler.workers.indexOf(threadId), 1); //Remove thread from task running pool
	    }
	  }, {
	    key: 'processReturn',
	    value: function processReturn(habitat, index, message, task) {
	      var output = message.data;
	      if (habitat.reactNative) {
	        output = JSON.parse(message).data;
	      } else if (typeof message.data.data !== "undefined") {
	        output = message.data.data;
	      }
	      if (task.scheduler.threads !== 1) {
	        _data2.default.addThreadOutputWithIndex(task, index, output);
	      } else {
	        task.input.array = output;
	      }
	    }
	  }, {
	    key: 'setOnMessage',
	    value: function setOnMessage(hamster, onThreadResponse, habitat, reject) {
	      if (habitat.webWorker) {
	        hamster.port.onmessage = onThreadResponse;
	        hamster.port.onmessageerror = reject;
	        hamster.port.onerror = reject;
	      }
	      if (habitat.node) {
	        hamster.once('message', onThreadResponse);
	        hamster.once('onmessageerror', reject);
	        hamster.once('error', reject);
	      } else {
	        hamster.onmessage = onThreadResponse;
	        hamster.onmessageerror = reject;
	        hamster.error = reject;
	      }
	    }
	
	    /**
	    * @function trainHamster - Trains thread in how to behave
	    * @param {number} threadId - Internal use id for this thread
	    * @param {object} task - Provided library functionality options for this task
	    * @param {worker} hamster - Thread to train
	    * @param {boolean} persistence - Whether persistence mode is enabled or not
	    * @param {function} resolve - onSuccess method
	    * @param {function} reject - onError method
	    */
	
	  }, {
	    key: 'trainHamster',
	    value: function trainHamster(pool, habitat, index, task, threadId, hamster, resolve, reject) {
	      var onThreadResponse = function onThreadResponse(message) {
	        pool.processReturn(habitat, index, message, task);
	        if (habitat.debug) {
	          task.scheduler.metrics.threads[threadId].completed_at = Date.now();
	        }
	        pool.removeFromRunning(task, threadId);
	        if (task.scheduler.workers.length === 0 && task.scheduler.count === task.scheduler.threads) {
	          pool.returnOutputAndRemoveTask(task, resolve);
	        }
	        if (pool.pending.length !== 0) {
	          return pool.processQueuedItem(hamster, pool.pending.shift());
	        }
	        if (!habitat.persistence) {
	          return hamster.terminate(); //Kill the thread only if no items waiting to run (20-22% performance improvement observed during testing, repurposing threads vs recreating them)
	        }
	      };
	      pool.setOnMessage(hamster, onThreadResponse, habitat, reject);
	    }
	
	    /**
	    * @function scheduleTask - Adds new task to the system for execution
	    * @param {object} task - Provided library functionality options for this task
	    * @param {boolean} persistence - Whether persistence mode is enabled or not
	    * @param {function} wheel - Scaffold to execute login within
	    * @param {number} maxThreads - Maximum number of threads for this client
	    */
	
	  }, {
	    key: 'scheduleTask',
	    value: function scheduleTask(task) {
	      var _this = this;
	
	      var i = 0;
	      if (_habitat2.default.debug) {
	        var metrics = task.scheduler.metrics;
	        metrics.started_at = Date.now();
	        return new Promise(function (resolve, reject) {
	          while (i < task.scheduler.threads) {
	            metrics.threads.push({
	              created_at: Date.now(),
	              started_at: null,
	              enqueued_at: null,
	              dequeued_at: null,
	              completed_at: null
	            });
	            _this.hamsterWheel(task.scheduler.indexes[i], task, resolve, reject);
	            i += 1;
	          }
	        });
	      }
	      //Process with debug mode disabled, no need for time stamping
	      return new Promise(function (resolve, reject) {
	        while (i < task.scheduler.threads) {
	          _this.hamsterWheel(task.scheduler.indexes[i], task, resolve, reject);
	          i += 1;
	        }
	      });
	    }
	  }]);
	
	  return pool;
	}();
	
	var hamsterPool = new pool();
	
	if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
	  module.exports = hamsterPool;
	}

/***/ }),
/* 6 */
/***/ (function(module, exports) {

	'use strict';
	
	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	/* jshint esversion: 6, curly: true, eqeqeq: true, forin: true */
	
	/***********************************************************************************
	* Title: Hamsters.js                                                               *
	* Description: 100% Vanilla Javascript Multithreading & Parallel Execution Library *
	* Author: Austin K. Smith                                                          *
	* Contact: austin@asmithdev.com                                                    *  
	* Copyright: 2015 Austin K. Smith - austin@asmithdev.com                           * 
	* License: Artistic License 2.0                                                    *
	***********************************************************************************/
	
	var data = function () {
	
	  /**
	  * @constructor
	  * @function constructor - Sets properties for this class
	  */
	  function data() {
	    'use strict';
	
	    _classCallCheck(this, data);
	
	    this.getSubArrayFromIndex = this.getSubArrayUsingIndex;
	    this.getSubArrayIndexes = this.calculateIndexes;
	    this.sortOutput = this.sortTaskOutput;
	    this.prepareFunction = this.prepareWorkerTask;
	    this.feedHamster = this.messageWorkerThread;
	  }
	
	  /**
	  * @function messageWorkerThread - Prepares message to send to thread
	  * @param {worker} hamster - Thread to message
	  * @param {object} hamsterFood - Message to send to thread
	  */
	
	
	  _createClass(data, [{
	    key: 'messageWorkerThread',
	    value: function messageWorkerThread(hamstersHabitat, hamster, hamsterFood) {
	      if (hamstersHabitat.reactNative) {
	        return hamster.postMessage(JSON.stringify(hamsterFood));
	      }
	      if (hamstersHabitat.webWorker) {
	        return hamster.port.postMessage(hamsterFood);
	      }
	      if (typeof hamsterFood.array.buffer !== 'undefined') {
	        hamster.postMessage(hamsterFood, [hamsterFood.array.buffer]);
	      } else {
	        hamster.postMessage(hamsterFood);
	      }
	    }
	
	    /**
	    * @function prepareWorkerTask - Prepares function for thread, strips whitespace
	    * @param {function} functionBody - Message to send to thread
	    */
	
	  }, {
	    key: 'prepareWorkerTask',
	    value: function prepareWorkerTask(functionBody) {
	      var functionString = String(functionBody);
	      return functionString.substring(functionString.indexOf("{") + 1, functionString.length - 1);
	    }
	
	    /**
	    * @function sortTaskOutput - Sorts array by defined order
	    * @param {object} arr - Array to sort
	    * @param {string} order - Defined sort order
	    */
	
	  }, {
	    key: 'sortTaskOutput',
	    value: function sortTaskOutput(arr, order) {
	      switch (order) {
	        case 'desc':
	        case 'asc':
	          return Array.prototype.sort.call(arr, function (a, b) {
	            return order === 'asc' ? a - b : b - a;
	          });
	        case 'ascAlpha':
	          return arr.sort();
	        case 'descAlpha':
	          return arr.reverse();
	        default:
	          return arr;
	      }
	    }
	
	    /**
	    * @function addThreadOutputWithIndex - Joins individual thread outputs into single result
	    * @param {array} input - Array of arrays to aggregate
	    * @param {string} dataType - Data type to use for typed array
	    */
	
	  }, {
	    key: 'addThreadOutputWithIndex',
	    value: function addThreadOutputWithIndex(task, index, output) {
	      var i = 0;
	      var outputLength = output.length;
	      for (i; i < outputLength; i++) {
	        task.input.array[index.start + i] = output[i];
	      }
	    }
	
	    /**
	    * @function calculateIndexes - Splits a single array into multiple equal sized subarrays
	    * @param {array} array - Array to split
	    * @param {number} n - Number of subarrays to create
	    */
	
	  }, {
	    key: 'calculateIndexes',
	    value: function calculateIndexes(array, n) {
	      var indexes = [];
	      var i = 0;
	      var size = Math.ceil(array.length / n);
	      for (var _i = 0; _i < array.length; _i += size) {
	        indexes.push({ start: _i, end: _i + size - 1 });
	      }
	      return indexes;
	    }
	
	    /**
	    * @function splitArrayIntoSubArrays - Splits a single array into multiple equal sized subarrays
	    * @param {array} array - Array to split
	    * @param {number} n - Number of subarrays to create
	    */
	
	  }, {
	    key: 'getSubArrayUsingIndex',
	    value: function getSubArrayUsingIndex(index, task) {
	      return task.input.array.slice(index.start, index.end + 1);
	    }
	  }]);
	
	  return data;
	}();
	
	var hamstersData = new data();
	
	if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
	  module.exports = hamstersData;
	}

/***/ })
/******/ ]);
//# sourceMappingURL=hamsters.web.min.js.map